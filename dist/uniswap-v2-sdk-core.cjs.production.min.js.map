{"version":3,"file":"uniswap-v2-sdk-core.cjs.production.min.js","sources":["../src/constants.ts","../src/env.ts","../src/addresses.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/percent.ts","../src/chains.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/price.ts","../src/entities/baseCurrency.ts","../src/entities/nativeCurrency.ts","../src/utils/validateAndParseAddress.ts","../src/entities/token.ts","../src/entities/weth9.ts","../src/entities/ether.ts","../src/utils/sqrt.ts","../src/errors.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/utils/computePriceImpact.ts","../src/utils/sortedInsert.ts","../src/entities/trade.ts","../src/utils/uniswapV2Library.ts","../src/utils/liquidityMath.ts","../src/utils/lpPositionTracker.ts","../src/router.ts"],"sourcesContent":["import { FACTORY_ADDRESSES } from './addresses'\n\nimport JSBI from 'jsbi'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | string | number\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const MaxUint256 = JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n\nexport const FACTORY_ADDRESS_MAP: { [chainId: number]: string } = FACTORY_ADDRESSES\n\nexport const INIT_CODE_HASH = '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const FIVE = JSBI.BigInt(5)\nexport const _997 = JSBI.BigInt(997)\nexport const _1000 = JSBI.BigInt(1000)\nexport const BASIS_POINTS = JSBI.BigInt(10000)\n","// Environment configuration\nexport const ENV = {\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  NETWORK: process.env.NETWORK || 'mainnet',\n  FACTORY_ADDRESS: process.env.FACTORY_ADDRESS,\n  ROUTER_ADDRESS: process.env.ROUTER_ADDRESS,\n  CHAIN_ID: process.env.CHAIN_ID ? parseInt(process.env.CHAIN_ID) : 1\n} as const\n\nexport type Environment = typeof ENV\n","import { ENV } from './env'\n\n// Contract addresses for different networks\nexport const FACTORY_ADDRESSES: { [chainId: number]: string } = {\n  1: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f', // Mainnet\n  3: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f', // Ropsten (for tests)\n  11155111: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f' // Sepolia\n}\n\nexport const ROUTER_ADDRESSES: { [chainId: number]: string } = {\n  1: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D', // Mainnet\n  3: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D', // Ropsten (for tests)\n  11155111: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D' // Sepolia\n}\n\n// Initialize addresses from environment variables if available\nif (ENV.FACTORY_ADDRESS && ENV.CHAIN_ID) {\n  FACTORY_ADDRESSES[ENV.CHAIN_ID] = ENV.FACTORY_ADDRESS\n}\n\nif (ENV.ROUTER_ADDRESS && ENV.CHAIN_ID) {\n  ROUTER_ADDRESSES[ENV.CHAIN_ID] = ENV.ROUTER_ADDRESS\n}\n\n// Helper functions to set addresses dynamically\nexport function setFactoryAddress(chainId: number, address: string): void {\n  FACTORY_ADDRESSES[chainId] = address\n}\n\nexport function setRouterAddress(chainId: number, address: string): void {\n  ROUTER_ADDRESSES[chainId] = address\n}\n\nexport function getFactoryAddress(chainId: number): string | undefined {\n  return FACTORY_ADDRESSES[chainId]\n}\n\nexport function getRouterAddress(chainId: number): string | undefined {\n  return ROUTER_ADDRESSES[chainId]\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = JSBI.BigInt(1)) {\n    this.numerator = JSBI.BigInt(numerator)\n    this.denominator = JSBI.BigInt(denominator)\n  }\n\n  private static tryParseFraction(fractionish: BigintIsh | Fraction): Fraction {\n    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string')\n      return new Fraction(fractionish)\n\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish\n    throw new Error('Could not parse fraction')\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n\n  /**\n   * Helper method for converting any super class back to a fraction\n   */\n  public get asFraction(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n}\n","import JSBI from 'jsbi'\nimport { BigintIsh, Rounding, ZERO, ONE } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst ONE_HUNDRED = new Fraction(JSBI.BigInt(100))\n\n/**\n * Converts a fraction to a percent\n * @param fraction the fraction to convert\n */\nfunction toPercent(fraction: Fraction): Percent {\n  return new Percent(fraction.numerator, fraction.denominator)\n}\n\nexport class Percent extends Fraction {\n  /**\n   * This boolean prevents a fraction from being interpreted as a Percent\n   */\n  public readonly isPercent: true = true\n\n  add(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.add(other))\n  }\n\n  subtract(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.subtract(other))\n  }\n\n  multiply(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.multiply(other))\n  }\n\n  divide(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.divide(other))\n  }\n\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return super.multiply(ONE_HUNDRED).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return super.multiply(ONE_HUNDRED).toFixed(decimalPlaces, format, rounding)\n  }\n}\n\nexport const ZERO_PERCENT = new Percent(ZERO)\nexport const ONE_HUNDRED_PERCENT = new Percent(ONE)\n","export enum ChainId {\n  MAINNET = 1,\n  ROPSTEN = 3, // For tests\n  SEPOLIA = 11155111,\n  BASE = 8453\n}\n\nexport const SUPPORTED_CHAINS = [ChainId.MAINNET, ChainId.ROPSTEN, ChainId.SEPOLIA, ChainId.BASE] as const\nexport type SupportedChainsType = typeof SUPPORTED_CHAINS[number]\n\nexport enum NativeCurrencyName {\n  // Strings match input for CLI\n  ETHER = 'ETH'\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { Currency } from '../currency'\nimport { Token } from '../token'\nimport { Fraction } from './fraction'\nimport _Big from 'big.js'\n\nimport toFormat from 'toformat'\nimport { BigintIsh, Rounding, MaxUint256 } from '../../constants'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount<T extends Currency> extends Fraction {\n  public readonly currency: T\n  public readonly decimalScale: JSBI\n\n  /**\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\n   * @param currency the currency in the amount\n   * @param rawAmount the raw token or ether amount\n   */\n  public static fromRawAmount<T extends Currency>(currency: T, rawAmount: BigintIsh): CurrencyAmount<T> {\n    return new CurrencyAmount(currency, rawAmount)\n  }\n\n  /**\n   * Construct a currency amount with a denominator that is not equal to 1\n   * @param currency the currency\n   * @param numerator the numerator of the fractional token amount\n   * @param denominator the denominator of the fractional token amount\n   */\n  public static fromFractionalAmount<T extends Currency>(\n    currency: T,\n    numerator: BigintIsh,\n    denominator: BigintIsh\n  ): CurrencyAmount<T> {\n    return new CurrencyAmount(currency, numerator, denominator)\n  }\n\n  protected constructor(currency: T, numerator: BigintIsh, denominator?: BigintIsh) {\n    super(numerator, denominator)\n    invariant(JSBI.lessThanOrEqual(this.quotient, MaxUint256), 'AMOUNT')\n    this.currency = currency\n    this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals))\n  }\n\n  public add(other: CurrencyAmount<T>): CurrencyAmount<T> {\n    invariant(this.currency.equals(other.currency), 'CURRENCY')\n    const added = super.add(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator)\n  }\n\n  public subtract(other: CurrencyAmount<T>): CurrencyAmount<T> {\n    invariant(this.currency.equals(other.currency), 'CURRENCY')\n    const subtracted = super.subtract(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator)\n  }\n\n  public multiply(other: Fraction | BigintIsh): CurrencyAmount<T> {\n    const multiplied = super.multiply(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator)\n  }\n\n  public divide(other: Fraction | BigintIsh): CurrencyAmount<T> {\n    const divided = super.divide(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator)\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.divide(this.decimalScale).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.divide(this.decimalScale).toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format)\n  }\n\n  public get wrapped(): CurrencyAmount<Token> {\n    if (this.currency.isToken) return this as CurrencyAmount<Token>\n    return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator)\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { Currency } from '../currency'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nexport class Price<TBase extends Currency, TQuote extends Currency> extends Fraction {\n  public readonly baseCurrency: TBase // input i.e. denominator\n  public readonly quoteCurrency: TQuote // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  /**\n   * Construct a price, either with the base and quote currency amount, or the\n   * @param args\n   */\n  public constructor(\n    ...args:\n      | [TBase, TQuote, BigintIsh, BigintIsh]\n      | [{ baseAmount: CurrencyAmount<TBase>; quoteAmount: CurrencyAmount<TQuote> }]\n  ) {\n    let baseCurrency: TBase, quoteCurrency: TQuote, denominator: BigintIsh, numerator: BigintIsh\n\n    if (args.length === 4) {\n      ;[baseCurrency, quoteCurrency, denominator, numerator] = args\n    } else {\n      const result = args[0].quoteAmount.divide(args[0].baseAmount)\n      ;[baseCurrency, quoteCurrency, denominator, numerator] = [\n        args[0].baseAmount.currency,\n        args[0].quoteAmount.currency,\n        result.denominator,\n        result.numerator\n      ]\n    }\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  /**\n   * Flip the price, switching the base and quote currency\n   */\n  public invert(): Price<TQuote, TBase> {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  /**\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\n   * @param other the other price\n   */\n  public multiply<TOtherQuote extends Currency>(other: Price<TQuote, TOtherQuote>): Price<TBase, TOtherQuote> {\n    invariant(this.quoteCurrency.equals(other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  /**\n   * Return the amount of quote currency corresponding to a given amount of the base currency\n   * @param currencyAmount the amount of base currency to quote against the price\n   */\n  public quote(currencyAmount: CurrencyAmount<TBase>): CurrencyAmount<TQuote> {\n    invariant(currencyAmount.currency.equals(this.baseCurrency), 'TOKEN')\n    const result = super.multiply(currencyAmount)\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator)\n  }\n\n  /**\n   * Get the value scaled by decimals for formatting\n   * @private\n   */\n  private get adjustedForDecimals(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { Token } from './token'\n\n/**\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\n */\nexport abstract class BaseCurrency {\n  /**\n   * Returns whether the currency is native to the chain and must be wrapped (e.g. Ether)\n   */\n  public abstract readonly isNative: boolean\n  /**\n   * Returns whether the currency is a token that is usable in Uniswap without wrapping\n   */\n  public abstract readonly isToken: boolean\n\n  /**\n   * The chain ID on which this currency resides\n   */\n  public readonly chainId: number\n  /**\n   * The decimals used in representing currency amounts\n   */\n  public readonly decimals: number\n  /**\n   * The symbol of the currency, i.e. a short textual non-unique identifier\n   */\n  public readonly symbol?: string\n  /**\n   * The name of the currency, i.e. a descriptive textual non-unique identifier\n   */\n  public readonly name?: string\n\n  /**\n   * Constructs an instance of the base class `BaseCurrency`.\n   * @param chainId the chain ID on which this currency resides\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(chainId: number, decimals: number, symbol?: string, name?: string) {\n    invariant(Number.isSafeInteger(chainId), 'CHAIN_ID')\n    invariant(decimals >= 0 && decimals < 255 && Number.isInteger(decimals), 'DECIMALS')\n\n    this.chainId = chainId\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n\n  /**\n   * Returns whether this currency is functionally equivalent to the other currency\n   * @param other the other currency\n   */\n  public abstract equals(other: Currency): boolean\n\n  /**\n   * Return the wrapped version of this currency that can be used with the Uniswap contracts. Currencies must\n   * implement this to be used in Uniswap\n   */\n  public abstract get wrapped(): Token\n}\n","import { BaseCurrency } from './baseCurrency'\n\n/**\n * Represents the native currency of the chain on which it resides, e.g.\n */\nexport abstract class NativeCurrency extends BaseCurrency {\n  public readonly isNative: true = true\n  public readonly isToken: false = false\n}\n","import { getAddress } from '@ethersproject/address'\n\n/**\n * Validates an address and returns the parsed (checksummed) version of that address\n * @param address the unchecksummed hex address\n */\nexport function validateAndParseAddress(address: string): string {\n  try {\n    return getAddress(address)\n  } catch (error) {\n    throw new Error(`${address} is not a valid address.`)\n  }\n}\n\n// Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x\nconst startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/\n\n/**\n * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.\n * @param address the unchecksummed hex address\n */\nexport function checkValidAddress(address: string): string {\n  if (startsWith0xLen42HexRegex.test(address)) {\n    return address\n  }\n\n  throw new Error(`${address} is not a valid address.`)\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport invariant from 'tiny-invariant'\nimport { checkValidAddress, validateAndParseAddress } from '../utils/validateAndParseAddress'\nimport { BaseCurrency } from './baseCurrency'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends BaseCurrency {\n  public readonly isNative: false = false\n  public readonly isToken: true = true\n\n  /**\n   * The contract address on the chain on which this token lives\n   */\n  public readonly address: string\n\n  /**\n   * Relevant for fee-on-transfer (FOT) token taxes,\n   * Not every ERC20 token is FOT token, so this field is optional\n   */\n  public readonly buyFeeBps?: BigNumber\n  public readonly sellFeeBps?: BigNumber\n\n  /**\n   *\n   * @param chainId {@link BaseCurrency#chainId}\n   * @param address The contract address on the chain on which this token lives\n   * @param decimals {@link BaseCurrency#decimals}\n   * @param symbol {@link BaseCurrency#symbol}\n   * @param name {@link BaseCurrency#name}\n   * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters\n   * @param buyFeeBps Buy fee tax for FOT tokens, in basis points\n   * @param sellFeeBps Sell fee tax for FOT tokens, in basis points\n   */\n  public constructor(\n    chainId: number,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    bypassChecksum?: boolean,\n    buyFeeBps?: BigNumber,\n    sellFeeBps?: BigNumber\n  ) {\n    super(chainId, decimals, symbol, name)\n    if (bypassChecksum) {\n      this.address = checkValidAddress(address)\n    } else {\n      this.address = validateAndParseAddress(address)\n    }\n    if (buyFeeBps) {\n      invariant(buyFeeBps.gte(BigNumber.from(0)), 'NON-NEGATIVE FOT FEES')\n    }\n    if (sellFeeBps) {\n      invariant(sellFeeBps.gte(BigNumber.from(0)), 'NON-NEGATIVE FOT FEES')\n    }\n    this.buyFeeBps = buyFeeBps\n    this.sellFeeBps = sellFeeBps\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Currency): boolean {\n    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase()\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address.toLowerCase() !== other.address.toLowerCase(), 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n\n  /**\n   * Return this token, which does not need to be wrapped\n   */\n  public get wrapped(): Token {\n    return this\n  }\n}\n","import { Token } from './token'\nimport { ChainId } from '../chains'\n\n/**\n * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped\n */\nexport const WETH9: { [chainId: number]: Token } = {\n  [ChainId.MAINNET]: new Token(\n    ChainId.MAINNET,\n    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n    18,\n    'WETH',\n    'Wrapped Ether'\n  ),\n  [ChainId.ROPSTEN]: new Token(\n    ChainId.ROPSTEN,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped Ether'\n  ),\n  [ChainId.SEPOLIA]: new Token(\n    ChainId.SEPOLIA,\n    '0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14',\n    18,\n    'WETH',\n    'Wrapped Ether'\n  ),\n  [ChainId.BASE]: new Token(ChainId.BASE, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether')\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { NativeCurrency } from './nativeCurrency'\nimport { Token } from './token'\nimport { WETH9 } from './weth9'\n\n/**\n * Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets\n */\nexport class Ether extends NativeCurrency {\n  protected constructor(chainId: number) {\n    super(chainId, 18, 'ETH', 'Ether')\n  }\n\n  public get wrapped(): Token {\n    const weth9 = WETH9[this.chainId]\n    invariant(!!weth9, 'WRAPPED')\n    return weth9\n  }\n\n  private static _etherCache: { [chainId: number]: Ether } = {}\n\n  public static onChain(chainId: number): Ether {\n    return this._etherCache[chainId] ?? (this._etherCache[chainId] = new Ether(chainId))\n  }\n\n  public equals(other: Currency): boolean {\n    return other.isNative && other.chainId === this.chainId\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\nexport const MAX_SAFE_INTEGER = JSBI.BigInt(Number.MAX_SAFE_INTEGER)\n\nconst ZERO = JSBI.BigInt(0)\nconst ONE = JSBI.BigInt(1)\nconst TWO = JSBI.BigInt(2)\n\n/**\n * Computes floor(sqrt(value))\n * @param value the value for which to compute the square root, rounded down\n */\nexport function sqrt(value: JSBI): JSBI {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), 'NEGATIVE')\n\n  // rely on built in sqrt if possible\n  if (JSBI.lessThan(value, MAX_SAFE_INTEGER)) {\n    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))))\n  }\n\n  let z: JSBI\n  let x: JSBI\n  z = value\n  x = JSBI.add(JSBI.divide(value, TWO), ONE)\n  while (JSBI.lessThan(x, z)) {\n    z = x\n    x = JSBI.divide(JSBI.add(JSBI.divide(value, x), x), TWO)\n  }\n  return z\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import { getCreate2Address } from '@ethersproject/address'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { keccak256, pack } from '@ethersproject/solidity'\nimport { BigintIsh } from '../constants'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { sqrt } from '../utils/sqrt'\nimport { Token } from './token'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\nimport {\n  _1000,\n  _997,\n  BASIS_POINTS,\n  FACTORY_ADDRESS_MAP,\n  FIVE,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ONE,\n  ZERO\n} from '../constants'\nimport { ONE_HUNDRED_PERCENT, ZERO_PERCENT } from './fractions/percent'\nimport { InsufficientInputAmountError, InsufficientReservesError } from '../errors'\n\nexport const computePairAddress = ({\n  factoryAddress,\n  tokenA,\n  tokenB\n}: {\n  factoryAddress: string\n  tokenA: Token\n  tokenB: Token\n}): string => {\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n  return getCreate2Address(\n    factoryAddress,\n    keccak256(['bytes'], [pack(['address', 'address'], [token0.address, token1.address])]),\n    INIT_CODE_HASH\n  )\n}\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [CurrencyAmount<Token>, CurrencyAmount<Token>]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    const factoryAddress = FACTORY_ADDRESS_MAP[tokenA.chainId]\n    invariant(factoryAddress, 'FACTORY_ADDRESS')\n    return computePairAddress({ factoryAddress, tokenA, tokenB })\n  }\n\n  public constructor(currencyAmountA: CurrencyAmount<Token>, tokenAmountB: CurrencyAmount<Token>) {\n    const tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [currencyAmountA, tokenAmountB]\n      : [tokenAmountB, currencyAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].currency.chainId,\n      Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency),\n      18,\n      'UNI-V2',\n      'Uniswap V2'\n    )\n    this.tokenAmounts = tokenAmounts as [CurrencyAmount<Token>, CurrencyAmount<Token>]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0])\n    return new Price(this.token0, this.token1, result.denominator, result.numerator)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1])\n    return new Price(this.token1, this.token0, result.denominator, result.numerator)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price<Token, Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].currency\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].currency\n  }\n\n  public get reserve0(): CurrencyAmount<Token> {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): CurrencyAmount<Token> {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  /**\n   * getAmountOut is the linear algebra of reserve ratio against amountIn:amountOut.\n   * https://ethereum.stackexchange.com/questions/101629/what-is-math-for-uniswap-calculates-the-amountout-and-amountin-why-997-and-1000\n   * has the math deduction for the reserve calculation without fee-on-transfer fees.\n   *\n   * With fee-on-transfer tax, intuitively it's just:\n   * inputAmountWithFeeAndTax = 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn\n   *                          = (1 - amountIn.sellFeesBips / 10000) * amountInWithFee\n   * where amountInWithFee is the amountIn after taking out the LP fees\n   * outputAmountWithTax = amountOut * (1 - amountOut.buyFeesBips / 10000)\n   *\n   * But we are illustrating the math deduction below to ensure that's the case.\n   *\n   * before swap A * B = K where A = reserveIn B = reserveOut\n   *\n   * after swap A' * B' = K where only k is a constant value\n   *\n   * getAmountOut\n   *\n   * A' = A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn # here 0.3% is deducted\n   * B' = B - amountOut * (1 - amountOut.buyFeesBips / 10000)\n   * amountOut = (B - B') / (1 - amountOut.buyFeesBips / 10000) # where A' * B' still is k\n   *           = (B - K/(A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn))\n   *             /\n   *             (1 - amountOut.buyFeesBips / 10000)\n   *           = (B - AB/(A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn))\n   *             /\n   *             (1 - amountOut.buyFeesBips / 10000)\n   *           = ((BA + B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn - AB)/(A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn))\n   *             /\n   *             (1 - amountOut.buyFeesBips / 10000)\n   *           = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn / (A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn)\n   *             /\n   *             (1 - amountOut.buyFeesBips / 10000)\n   * amountOut * (1 - amountOut.buyFeesBips / 10000) = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn\n   *                                                    /\n   *                                                    (A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn)\n   *\n   * outputAmountWithTax = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn\n   *                       /\n   *                       (A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn)\n   *                       = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn * 1000\n   *                       /\n   *                       ((A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn) * 1000)\n   *                     = (B * (1 - amountIn.sellFeesBips / 10000) 997 * * amountIn\n   *                       /\n   *                       (1000 * A + (1 - amountIn.sellFeesBips / 10000) * 997 * amountIn)\n   *                     = (B * (1 - amountIn.sellFeesBips / 10000) * inputAmountWithFee)\n   *                       /\n   *                       (1000 * A + (1 - amountIn.sellFeesBips / 10000) * inputAmountWithFee)\n   *                     = (B * inputAmountWithFeeAndTax)\n   *                       /\n   *                       (1000 * A + inputAmountWithFeeAndTax)\n   *\n   * inputAmountWithFeeAndTax = (1 - amountIn.sellFeesBips / 10000) * inputAmountWithFee\n   * outputAmountWithTax = amountOut * (1 - amountOut.buyFeesBips / 10000)\n   *\n   * @param inputAmount\n   * @param calculateFotFees\n   */\n  public getOutputAmount(\n    inputAmount: CurrencyAmount<Token>,\n    calculateFotFees: boolean = true\n  ): [CurrencyAmount<Token>, Pair] {\n    invariant(this.involvesToken(inputAmount.currency), 'TOKEN')\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.currency)\n    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n\n    const percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT\n    const inputAmountAfterTax = percentAfterSellFees.greaterThan(ZERO_PERCENT)\n      ? CurrencyAmount.fromRawAmount(\n          inputAmount.currency,\n          percentAfterSellFees.multiply(inputAmount).quotient // fraction.quotient will round down by itself, which is desired\n        )\n      : inputAmount\n\n    const inputAmountWithFeeAndAfterTax = JSBI.multiply(inputAmountAfterTax.quotient, _997)\n    const numerator = JSBI.multiply(inputAmountWithFeeAndAfterTax, outputReserve.quotient)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _1000), inputAmountWithFeeAndAfterTax)\n    const outputAmount = CurrencyAmount.fromRawAmount(\n      inputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator) // JSBI.divide will round down by itself, which is desired\n    )\n\n    if (JSBI.equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n\n    const percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT\n    const outputAmountAfterTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT)\n      ? CurrencyAmount.fromRawAmount(\n          outputAmount.currency,\n          outputAmount.multiply(percentAfterBuyFees).quotient // fraction.quotient will round down by itself, which is desired\n        )\n      : outputAmount\n    if (JSBI.equal(outputAmountAfterTax.quotient, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n\n    return [\n      outputAmountAfterTax,\n      new Pair(inputReserve.add(inputAmountAfterTax), outputReserve.subtract(outputAmountAfterTax))\n    ]\n  }\n\n  /**\n   * getAmountIn is the linear algebra of reserve ratio against amountIn:amountOut.\n   * https://ethereum.stackexchange.com/questions/101629/what-is-math-for-uniswap-calculates-the-amountout-and-amountin-why-997-and-1000\n   * has the math deduction for the reserve calculation without fee-on-transfer fees.\n   *\n   * With fee-on-transfer fees, intuitively it's just:\n   * outputAmountWithTax = amountOut / (1 - amountOut.buyFeesBips / 10000)\n   * inputAmountWithTax = amountIn / (1 - amountIn.sellFeesBips / 10000) / 0.997\n   *\n   * But we are illustrating the math deduction below to ensure that's the case.\n   *\n   * before swap A * B = K where A = reserveIn B = reserveOut\n   *\n   * after swap A' * B' = K where only k is a constant value\n   *\n   * getAmountIn\n   *\n   * B' = B - amountOut * (1 - amountOut.buyFeesBips / 10000)\n   * A' = A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn # here 0.3% is deducted\n   * amountIn = (A' - A) / (0.997 * (1 - amountIn.sellFeesBips / 10000))\n   *          = (K / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)) - A)\n   *            /\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\n   *          = (AB / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)) - A)\n   *            /\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\n   *          = ((AB - AB + A * amountOut / (1 - amountOut.buyFeesBips / 10000)) / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)))\n   *            /\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\n   *          = ((A * amountOut / (1 - amountOut.buyFeesBips / 10000)) / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)))\n   *            /\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\n   *          = ((A * 1000 * amountOut / (1 - amountOut.buyFeesBips / 10000)) / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)))\n   *            /\n   *            (997 * (1 - amountIn.sellFeesBips / 10000))\n   *\n   * outputAmountWithTax = amountOut / (1 - amountOut.buyFeesBips / 10000)\n   * inputAmountWithTax = amountIn / (997 * (1 - amountIn.sellFeesBips / 10000))\n   *                    = (A * outputAmountWithTax * 1000) / ((B - outputAmountWithTax) * 997)\n   *\n   * @param outputAmount\n   */\n  public getInputAmount(\n    outputAmount: CurrencyAmount<Token>,\n    calculateFotFees: boolean = true\n  ): [CurrencyAmount<Token>, Pair] {\n    invariant(this.involvesToken(outputAmount.currency), 'TOKEN')\n    const percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT\n    const outputAmountBeforeTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT)\n      ? CurrencyAmount.fromRawAmount(\n          outputAmount.currency,\n          JSBI.add(outputAmount.divide(percentAfterBuyFees).quotient, ONE) // add 1 for rounding up\n        )\n      : outputAmount\n\n    if (\n      JSBI.equal(this.reserve0.quotient, ZERO) ||\n      JSBI.equal(this.reserve1.quotient, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient) ||\n      JSBI.greaterThanOrEqual(outputAmountBeforeTax.quotient, this.reserveOf(outputAmount.currency).quotient)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.currency)\n    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmountBeforeTax.quotient), _1000)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmountBeforeTax.quotient), _997)\n    const inputAmount = CurrencyAmount.fromRawAmount(\n      outputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE) // add 1 here is part of the formula, no rounding needed here, since there will not be decimal at this point\n    )\n\n    const percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT\n    const inputAmountBeforeTax = percentAfterSellFees.greaterThan(ZERO_PERCENT)\n      ? CurrencyAmount.fromRawAmount(\n          inputAmount.currency,\n          JSBI.add(inputAmount.divide(percentAfterSellFees).quotient, ONE) // add 1 for rounding up\n        )\n      : inputAmount\n    return [inputAmountBeforeTax, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: CurrencyAmount<Token>,\n    tokenAmountA: CurrencyAmount<Token>,\n    tokenAmountB: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(\n        sqrt(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)),\n        MINIMUM_LIQUIDITY\n      )\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: CurrencyAmount<Token>,\n    liquidity: CurrencyAmount<Token>,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: CurrencyAmount<Token>\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = JSBI.BigInt(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return CurrencyAmount.fromRawAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient)\n    )\n  }\n\n  private derivePercentAfterSellFees(inputAmount: CurrencyAmount<Token>): Percent {\n    const sellFeeBips = this.token0.wrapped.equals(inputAmount.wrapped.currency)\n      ? this.token0.wrapped.sellFeeBps\n      : this.token1.wrapped.sellFeeBps\n    if (sellFeeBips?.gt(BigNumber.from(0))) {\n      return ONE_HUNDRED_PERCENT.subtract(new Percent(JSBI.BigInt(sellFeeBips)).divide(BASIS_POINTS))\n    } else {\n      return ZERO_PERCENT\n    }\n  }\n\n  private derivePercentAfterBuyFees(outputAmount: CurrencyAmount<Token>): Percent {\n    const buyFeeBps = this.token0.wrapped.equals(outputAmount.wrapped.currency)\n      ? this.token0.wrapped.buyFeeBps\n      : this.token1.wrapped.buyFeeBps\n    if (buyFeeBps?.gt(BigNumber.from(0))) {\n      return ONE_HUNDRED_PERCENT.subtract(new Percent(JSBI.BigInt(buyFeeBps)).divide(BASIS_POINTS))\n    } else {\n      return ZERO_PERCENT\n    }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { Price } from './fractions/price'\nimport { Token } from './token'\n\nimport { Pair } from './pair'\n\nexport class Route<TInput extends Currency, TOutput extends Currency> {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  public constructor(pairs: Pair[], input: TInput, output: TOutput) {\n    invariant(pairs.length > 0, 'PAIRS')\n    const chainId: number = pairs[0].chainId\n    invariant(\n      pairs.every(pair => pair.chainId === chainId),\n      'CHAIN_IDS'\n    )\n\n    const wrappedInput = input.wrapped\n    invariant(pairs[0].involvesToken(wrappedInput), 'INPUT')\n    invariant(typeof output === 'undefined' || pairs[pairs.length - 1].involvesToken(output.wrapped), 'OUTPUT')\n\n    const path: Token[] = [wrappedInput]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.input = input\n    this.output = output\n  }\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n    const prices: Price<Currency, Currency>[] = []\n    for (const [i, pair] of this.pairs.entries()) {\n      prices.push(\n        this.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient)\n      )\n    }\n    const reduced = prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n    return (this._midPrice = new Price(this.input, this.output, reduced.denominator, reduced.numerator))\n  }\n\n  public get chainId(): number {\n    return this.pairs[0].chainId\n  }\n}\n","import { Currency } from '../entities/currency'\nimport { CurrencyAmount } from '../entities/fractions/currencyAmount'\nimport { Percent } from '../entities/fractions/percent'\nimport { Price } from '../entities/fractions/price'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nexport function computePriceImpact<TBase extends Currency, TQuote extends Currency>(\n  midPrice: Price<TBase, TQuote>,\n  inputAmount: CurrencyAmount<TBase>,\n  outputAmount: CurrencyAmount<TQuote>\n): Percent {\n  const quotedOutputAmount = midPrice.quote(inputAmount)\n  // calculate price impact := (exactQuote - outputAmount) / exactQuote\n  const priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount)\n  return new Percent(priceImpact.numerator, priceImpact.denominator)\n}\n","import invariant from 'tiny-invariant'\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","import { computePriceImpact } from '../utils/computePriceImpact'\nimport { Token } from './token'\nimport { Currency } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { sortedInsert } from '../utils/sortedInsert'\nimport { TradeType, ONE, ZERO } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Pair } from './pair'\nimport { Route } from './route'\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput<TInput extends Currency, TOutput extends Currency> {\n  readonly inputAmount: CurrencyAmount<TInput>\n  readonly outputAmount: CurrencyAmount<TOutput>\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator<TInput extends Currency, TOutput extends Currency>(\n  a: InputOutput<TInput, TOutput>,\n  b: InputOutput<TInput, TOutput>\n): number {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: Trade<TInput, TOutput, TTradeType>,\n  b: Trade<TInput, TOutput, TTradeType>\n) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through and the input/output currencies.\n   */\n  public readonly route: Route<TInput, TOutput>\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount<TInput>\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount<TOutput>\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price<TInput, TOutput>\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn<TInput extends Currency, TOutput extends Currency>(\n    route: Route<TInput, TOutput>,\n    amountIn: CurrencyAmount<TInput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT> {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut<TInput extends Currency, TOutput extends Currency>(\n    route: Route<TInput, TOutput>,\n    amountOut: CurrencyAmount<TOutput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT> {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(\n    route: Route<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ) {\n    this.route = route\n    this.tradeType = tradeType\n\n    const tokenAmounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      tokenAmounts[0] = amount.wrapped\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount] = pair.getOutputAmount(tokenAmounts[i])\n        tokenAmounts[i + 1] = outputAmount\n      }\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        tokenAmounts[tokenAmounts.length - 1].numerator,\n        tokenAmounts[tokenAmounts.length - 1].denominator\n      )\n    } else {\n      invariant(amount.currency.equals(route.output), 'OUTPUT')\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount] = pair.getInputAmount(tokenAmounts[i])\n        tokenAmounts[i - 1] = inputAmount\n      }\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(\n        route.input,\n        tokenAmounts[0].numerator,\n        tokenAmounts[0].denominator\n      )\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator)\n    }\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.quotient,\n      this.outputAmount.quotient\n    )\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.quotient)\n        .quotient\n      return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn.wrapped\n    const tokenOut = currencyOut.wrapped\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: CurrencyAmount<Token>\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param nextAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(\n    pairs: Pair[],\n    currencyIn: TInput,\n    currencyAmountOut: CurrencyAmount<TOutput>,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    nextAmountOut: CurrencyAmount<Currency> = currencyAmountOut,\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] = []\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountOut === nextAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    const amountOut = nextAmountOut.wrapped\n    const tokenIn = currencyIn.wrapped\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: CurrencyAmount<Token>\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.currency.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency),\n            currencyAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          currencyAmountOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          amountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\n/**\n * Returns sorted token addresses, used to handle return values from pairs sorted in this order\n */\nexport function sortTokens(tokenA: string, tokenB: string): [string, string] {\n  invariant(tokenA !== tokenB, 'IDENTICAL_ADDRESSES')\n  const [token0, token1] = tokenA.toLowerCase() < tokenB.toLowerCase() ? [tokenA, tokenB] : [tokenB, tokenA]\n  invariant(token0.toLowerCase() !== '0x0000000000000000000000000000000000000000', 'ZERO_ADDRESS')\n  return [token0, token1]\n}\n\n/**\n * Calculates the CREATE2 address for a pair without making any external calls\n * Note: This is a simplified version for demonstration purposes\n */\nexport function pairFor(factory: string, tokenA: string, tokenB: string, initCodeHash: string): string {\n  const [token0, token1] = sortTokens(tokenA, tokenB)\n\n  // In a real implementation, this would calculate the CREATE2 address\n  // For now, return a mock address that's deterministic based on inputs\n  const combined = factory + token0 + token1 + initCodeHash\n  const mockAddress = '0x' + combined.slice(-40).padStart(40, '0')\n\n  return mockAddress\n}\n\n/**\n * Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n */\nexport function quote(amountA: JSBI, reserveA: JSBI, reserveB: JSBI): JSBI {\n  invariant(JSBI.greaterThan(amountA, JSBI.BigInt(0)), 'INSUFFICIENT_AMOUNT')\n  invariant(\n    JSBI.greaterThan(reserveA, JSBI.BigInt(0)) && JSBI.greaterThan(reserveB, JSBI.BigInt(0)),\n    'INSUFFICIENT_LIQUIDITY'\n  )\n  return JSBI.divide(JSBI.multiply(amountA, reserveB), reserveA)\n}\n\n/**\n * Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n */\nexport function getAmountOut(amountIn: JSBI, reserveIn: JSBI, reserveOut: JSBI): JSBI {\n  invariant(JSBI.greaterThan(amountIn, JSBI.BigInt(0)), 'INSUFFICIENT_INPUT_AMOUNT')\n  invariant(\n    JSBI.greaterThan(reserveIn, JSBI.BigInt(0)) && JSBI.greaterThan(reserveOut, JSBI.BigInt(0)),\n    'INSUFFICIENT_LIQUIDITY'\n  )\n\n  const amountInWithFee = JSBI.multiply(amountIn, JSBI.BigInt(997))\n  const numerator = JSBI.multiply(amountInWithFee, reserveOut)\n  const denominator = JSBI.add(JSBI.multiply(reserveIn, JSBI.BigInt(1000)), amountInWithFee)\n  return JSBI.divide(numerator, denominator)\n}\n\n/**\n * Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n */\nexport function getAmountIn(amountOut: JSBI, reserveIn: JSBI, reserveOut: JSBI): JSBI {\n  invariant(JSBI.greaterThan(amountOut, JSBI.BigInt(0)), 'INSUFFICIENT_OUTPUT_AMOUNT')\n  invariant(\n    JSBI.greaterThan(reserveIn, JSBI.BigInt(0)) && JSBI.greaterThan(reserveOut, JSBI.BigInt(0)),\n    'INSUFFICIENT_LIQUIDITY'\n  )\n\n  const numerator = JSBI.multiply(JSBI.multiply(reserveIn, amountOut), JSBI.BigInt(1000))\n  const denominator = JSBI.multiply(JSBI.subtract(reserveOut, amountOut), JSBI.BigInt(997))\n  return JSBI.add(JSBI.divide(numerator, denominator), JSBI.BigInt(1))\n}\n\n/**\n * Performs chained getAmountOut calculations on any number of pairs\n */\nexport function getAmountsOut(amountIn: JSBI, reserves: Array<[JSBI, JSBI]>): JSBI[] {\n  invariant(reserves.length >= 1, 'INVALID_PATH')\n  const amounts: JSBI[] = new Array(reserves.length + 1)\n  amounts[0] = amountIn\n  for (let i = 0; i < reserves.length; i++) {\n    amounts[i + 1] = getAmountOut(amounts[i], reserves[i][0], reserves[i][1])\n  }\n  return amounts\n}\n\n/**\n * Performs chained getAmountIn calculations on any number of pairs\n */\nexport function getAmountsIn(amountOut: JSBI, reserves: Array<[JSBI, JSBI]>): JSBI[] {\n  invariant(reserves.length >= 1, 'INVALID_PATH')\n  const amounts: JSBI[] = new Array(reserves.length + 1)\n  amounts[amounts.length - 1] = amountOut\n  for (let i = reserves.length - 1; i >= 0; i--) {\n    amounts[i] = getAmountIn(amounts[i + 1], reserves[i][0], reserves[i][1])\n  }\n  return amounts\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { sqrt } from './sqrt'\nimport { getAmountOut } from './uniswapV2Library'\n\n/**\n * Computes the direction and magnitude of the profit-maximizing trade\n * @param truePriceTokenA The true price of token A\n * @param truePriceTokenB The true price of token B\n * @param reserveA Reserve of token A\n * @param reserveB Reserve of token B\n * @returns [aToB: boolean, amountIn: JSBI] - direction and amount for profit-maximizing trade\n */\nexport function computeProfitMaximizingTrade(\n  truePriceTokenA: JSBI,\n  truePriceTokenB: JSBI,\n  reserveA: JSBI,\n  reserveB: JSBI\n): [boolean, JSBI] {\n  invariant(\n    JSBI.greaterThan(truePriceTokenA, JSBI.BigInt(0)) && JSBI.greaterThan(truePriceTokenB, JSBI.BigInt(0)),\n    'INVALID_PRICES'\n  )\n  invariant(\n    JSBI.greaterThan(reserveA, JSBI.BigInt(0)) && JSBI.greaterThan(reserveB, JSBI.BigInt(0)),\n    'INSUFFICIENT_RESERVES'\n  )\n\n  // Current price in pool: reserveB / reserveA\n  // True price ratio: truePriceTokenB / truePriceTokenA\n  // If current price < true price, A is undervalued, sell B to buy A (aToB = false)\n  // If current price > true price, A is overvalued, sell A to buy B (aToB = true)\n\n  const currentPrice = JSBI.divide(JSBI.multiply(reserveB, truePriceTokenA), reserveA)\n  const aToB = JSBI.greaterThan(currentPrice, truePriceTokenB)\n\n  if (JSBI.equal(currentPrice, truePriceTokenB)) {\n    return [false, JSBI.BigInt(0)]\n  }\n\n  const invariantValue = JSBI.multiply(reserveA, reserveB)\n\n  try {\n    const leftSide = sqrt(\n      JSBI.divide(\n        JSBI.multiply(JSBI.multiply(invariantValue, JSBI.BigInt(1000)), aToB ? truePriceTokenA : truePriceTokenB),\n        JSBI.multiply(aToB ? truePriceTokenB : truePriceTokenA, JSBI.BigInt(997))\n      )\n    )\n\n    const rightSide = JSBI.divide(JSBI.multiply(aToB ? reserveA : reserveB, JSBI.BigInt(1000)), JSBI.BigInt(997))\n\n    if (JSBI.lessThan(leftSide, rightSide)) {\n      return [false, JSBI.BigInt(0)]\n    }\n\n    const amountIn = JSBI.subtract(leftSide, rightSide)\n    return [aToB, amountIn]\n  } catch (error) {\n    return [false, JSBI.BigInt(0)]\n  }\n}\n\n/**\n * Gets the reserves after an arbitrage moves the price to the profit-maximizing ratio\n * @param reserveA Initial reserve of token A\n * @param reserveB Initial reserve of token B\n * @param truePriceTokenA The true price of token A\n * @param truePriceTokenB The true price of token B\n * @returns [reserveA: JSBI, reserveB: JSBI] - reserves after arbitrage\n */\nexport function getReservesAfterArbitrage(\n  reserveA: JSBI,\n  reserveB: JSBI,\n  truePriceTokenA: JSBI,\n  truePriceTokenB: JSBI\n): [JSBI, JSBI] {\n  invariant(\n    JSBI.greaterThan(reserveA, JSBI.BigInt(0)) && JSBI.greaterThan(reserveB, JSBI.BigInt(0)),\n    'ZERO_PAIR_RESERVES'\n  )\n\n  const [aToB, amountIn] = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB)\n\n  if (JSBI.equal(amountIn, JSBI.BigInt(0))) {\n    return [reserveA, reserveB]\n  }\n\n  if (aToB) {\n    const amountOut = getAmountOut(amountIn, reserveA, reserveB)\n    return [JSBI.add(reserveA, amountIn), JSBI.subtract(reserveB, amountOut)]\n  } else {\n    const amountOut = getAmountOut(amountIn, reserveB, reserveA)\n    return [JSBI.subtract(reserveA, amountOut), JSBI.add(reserveB, amountIn)]\n  }\n}\n\n/**\n * Computes liquidity value given all the parameters of the pair\n * @param reservesA Reserve of token A\n * @param reservesB Reserve of token B\n * @param totalSupply Total supply of liquidity tokens\n * @param liquidityAmount Amount of liquidity tokens\n * @param feeOn Whether protocol fee is on\n * @param kLast Last invariant value (for fee calculation)\n * @returns [tokenAAmount: JSBI, tokenBAmount: JSBI] - amounts of token A and B\n */\nexport function computeLiquidityValue(\n  reservesA: JSBI,\n  reservesB: JSBI,\n  totalSupply: JSBI,\n  liquidityAmount: JSBI,\n  feeOn: boolean,\n  kLast: JSBI\n): [JSBI, JSBI] {\n  let adjustedTotalSupply = totalSupply\n\n  if (feeOn && JSBI.greaterThan(kLast, JSBI.BigInt(0))) {\n    const rootK = sqrt(JSBI.multiply(reservesA, reservesB))\n    const rootKLast = sqrt(kLast)\n\n    if (JSBI.greaterThan(rootK, rootKLast)) {\n      const numerator1 = totalSupply\n      const numerator2 = JSBI.subtract(rootK, rootKLast)\n      const denominator = JSBI.add(JSBI.multiply(rootK, JSBI.BigInt(5)), rootKLast)\n      const feeLiquidity = JSBI.divide(JSBI.multiply(numerator1, numerator2), denominator)\n      adjustedTotalSupply = JSBI.add(totalSupply, feeLiquidity)\n    }\n  }\n\n  return [\n    JSBI.divide(JSBI.multiply(reservesA, liquidityAmount), adjustedTotalSupply),\n    JSBI.divide(JSBI.multiply(reservesB, liquidityAmount), adjustedTotalSupply)\n  ]\n}\n\n/**\n * Interface for pair information needed for liquidity calculations\n */\nexport interface PairReserves {\n  reserveA: JSBI\n  reserveB: JSBI\n  totalSupply: JSBI\n  kLast: JSBI\n  feeOn: boolean\n}\n\n/**\n * Computes the value of liquidity tokens in terms of underlying tokens\n * @param pairReserves Current reserves and metadata for the pair\n * @param liquidityAmount Amount of liquidity tokens to value\n * @returns [tokenAAmount: JSBI, tokenBAmount: JSBI] - underlying token amounts\n */\nexport function getLiquidityValue(pairReserves: PairReserves, liquidityAmount: JSBI): [JSBI, JSBI] {\n  return computeLiquidityValue(\n    pairReserves.reserveA,\n    pairReserves.reserveB,\n    pairReserves.totalSupply,\n    liquidityAmount,\n    pairReserves.feeOn,\n    pairReserves.kLast\n  )\n}\n\n/**\n * Computes the value of liquidity tokens after arbitrage to true price\n * @param pairReserves Current reserves and metadata for the pair\n * @param truePriceTokenA The true price of token A\n * @param truePriceTokenB The true price of token B\n * @param liquidityAmount Amount of liquidity tokens to value\n * @returns [tokenAAmount: JSBI, tokenBAmount: JSBI] - underlying token amounts after arbitrage\n */\nexport function getLiquidityValueAfterArbitrageToPrice(\n  pairReserves: PairReserves,\n  truePriceTokenA: JSBI,\n  truePriceTokenB: JSBI,\n  liquidityAmount: JSBI\n): [JSBI, JSBI] {\n  invariant(\n    JSBI.greaterThanOrEqual(pairReserves.totalSupply, liquidityAmount) &&\n      JSBI.greaterThan(liquidityAmount, JSBI.BigInt(0)),\n    'INVALID_LIQUIDITY_AMOUNT'\n  )\n\n  const [reservesA, reservesB] = getReservesAfterArbitrage(\n    pairReserves.reserveA,\n    pairReserves.reserveB,\n    truePriceTokenA,\n    truePriceTokenB\n  )\n\n  return computeLiquidityValue(\n    reservesA,\n    reservesB,\n    pairReserves.totalSupply,\n    liquidityAmount,\n    pairReserves.feeOn,\n    pairReserves.kLast\n  )\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { checkValidAddress } from './validateAndParseAddress'\n\n/**\n * Represents an LP Position with detailed information\n */\nexport interface LPPosition {\n  pool: string // Pool contract address\n  tokenA: string // First token address\n  tokenB: string // Second token address\n  balance: JSBI // LP token balance\n  reserveA: JSBI // Token A reserves in pool\n  reserveB: JSBI // Token B reserves in pool\n  totalSupply: JSBI // Total LP token supply\n  sharePercentage: JSBI // User's share of the pool (in basis points, 10000 = 100%)\n}\n\n/**\n * Paginated result for LP pools\n */\nexport interface LPPoolsResult {\n  pools: string[]\n  hasMore: boolean\n}\n\n/**\n * Paginated result for LP positions\n */\nexport interface LPPositionsResult {\n  positions: LPPosition[]\n  hasMore: boolean\n}\n\n/**\n * Interface for LP position data provider\n * This would typically be implemented by a class that interacts with blockchain data\n */\nexport interface LPDataProvider {\n  getUserLPPoolCount(user: string): Promise<JSBI>\n  getUserLPPools(user: string, offset: JSBI, limit: JSBI): Promise<LPPoolsResult>\n  getUserLPBalance(user: string, pool: string): Promise<JSBI>\n  getUserLPPositions(user: string, offset: JSBI, limit: JSBI): Promise<LPPositionsResult>\n  hasLPPosition(user: string, pool: string): Promise<boolean>\n  getPoolInfo(\n    pool: string\n  ): Promise<{\n    tokenA: string\n    tokenB: string\n    reserveA: JSBI\n    reserveB: JSBI\n    totalSupply: JSBI\n  }>\n}\n\n/**\n * Mock implementation of LP data provider for testing and demonstration\n */\nexport class MockLPDataProvider implements LPDataProvider {\n  private userPools: Map<string, Set<string>> = new Map()\n  private userBalances: Map<string, Map<string, JSBI>> = new Map()\n  private poolData: Map<\n    string,\n    {\n      tokenA: string\n      tokenB: string\n      reserveA: JSBI\n      reserveB: JSBI\n      totalSupply: JSBI\n    }\n  > = new Map()\n\n  /**\n   * Add mock data for testing\n   */\n  addMockUserPosition(user: string, pool: string, balance: JSBI) {\n    user = checkValidAddress(user)\n    pool = checkValidAddress(pool)\n\n    if (!this.userPools.has(user)) {\n      this.userPools.set(user, new Set())\n    }\n    this.userPools.get(user)!.add(pool)\n\n    if (!this.userBalances.has(user)) {\n      this.userBalances.set(user, new Map())\n    }\n    this.userBalances.get(user)!.set(pool, balance)\n  }\n\n  /**\n   * Add mock pool data\n   */\n  addMockPoolData(pool: string, tokenA: string, tokenB: string, reserveA: JSBI, reserveB: JSBI, totalSupply: JSBI) {\n    this.poolData.set(checkValidAddress(pool), {\n      tokenA: checkValidAddress(tokenA),\n      tokenB: checkValidAddress(tokenB),\n      reserveA,\n      reserveB,\n      totalSupply\n    })\n  }\n\n  async getUserLPPoolCount(user: string): Promise<JSBI> {\n    user = checkValidAddress(user)\n    const pools = this.userPools.get(user)\n    return JSBI.BigInt(pools ? pools.size : 0)\n  }\n\n  async getUserLPPools(user: string, offset: JSBI, limit: JSBI): Promise<LPPoolsResult> {\n    user = checkValidAddress(user)\n    const pools = this.userPools.get(user)\n\n    if (!pools) {\n      return { pools: [], hasMore: false }\n    }\n\n    const poolArray = Array.from(pools)\n    const offsetNum = JSBI.toNumber(offset)\n    const limitNum = JSBI.toNumber(limit)\n\n    const sliced = poolArray.slice(offsetNum, offsetNum + limitNum)\n    const hasMore = offsetNum + limitNum < poolArray.length\n\n    return {\n      pools: sliced,\n      hasMore\n    }\n  }\n\n  async getUserLPBalance(user: string, pool: string): Promise<JSBI> {\n    user = checkValidAddress(user)\n    pool = checkValidAddress(pool)\n\n    const userBalances = this.userBalances.get(user)\n    if (!userBalances) {\n      return JSBI.BigInt(0)\n    }\n\n    return userBalances.get(pool) || JSBI.BigInt(0)\n  }\n\n  async getUserLPPositions(user: string, offset: JSBI, limit: JSBI): Promise<LPPositionsResult> {\n    user = checkValidAddress(user)\n    const poolsResult = await this.getUserLPPools(user, offset, limit)\n\n    const positions: LPPosition[] = []\n\n    for (const pool of poolsResult.pools) {\n      const balance = await this.getUserLPBalance(user, pool)\n      const poolInfo = await this.getPoolInfo(pool)\n\n      // Calculate share percentage (balance / totalSupply * 10000)\n      const sharePercentage = JSBI.equal(poolInfo.totalSupply, JSBI.BigInt(0))\n        ? JSBI.BigInt(0)\n        : JSBI.divide(JSBI.multiply(balance, JSBI.BigInt(10000)), poolInfo.totalSupply)\n\n      positions.push({\n        pool,\n        tokenA: poolInfo.tokenA,\n        tokenB: poolInfo.tokenB,\n        balance,\n        reserveA: poolInfo.reserveA,\n        reserveB: poolInfo.reserveB,\n        totalSupply: poolInfo.totalSupply,\n        sharePercentage\n      })\n    }\n\n    return {\n      positions,\n      hasMore: poolsResult.hasMore\n    }\n  }\n\n  async hasLPPosition(user: string, pool: string): Promise<boolean> {\n    const balance = await this.getUserLPBalance(user, pool)\n    return JSBI.greaterThan(balance, JSBI.BigInt(0))\n  }\n\n  async getPoolInfo(\n    pool: string\n  ): Promise<{\n    tokenA: string\n    tokenB: string\n    reserveA: JSBI\n    reserveB: JSBI\n    totalSupply: JSBI\n  }> {\n    pool = checkValidAddress(pool)\n    const info = this.poolData.get(pool)\n\n    if (!info) {\n      throw new Error(`Pool data not found for ${pool}`)\n    }\n\n    return info\n  }\n}\n\n/**\n * LP Position Tracker class that provides high-level functions\n */\nexport class LPPositionTracker {\n  constructor(private dataProvider: LPDataProvider) {}\n\n  /**\n   * Get the number of LP pools a user has positions in\n   */\n  async getUserLPPoolCount(user: string): Promise<JSBI> {\n    return this.dataProvider.getUserLPPoolCount(user)\n  }\n\n  /**\n   * Get paginated list of LP pools where user has positions\n   */\n  async getUserLPPools(user: string, offset: JSBI, limit: JSBI): Promise<LPPoolsResult> {\n    invariant(JSBI.greaterThanOrEqual(offset, JSBI.BigInt(0)), 'INVALID_OFFSET')\n    invariant(JSBI.greaterThan(limit, JSBI.BigInt(0)), 'INVALID_LIMIT')\n\n    return this.dataProvider.getUserLPPools(user, offset, limit)\n  }\n\n  /**\n   * Get user's LP token balance in a specific pool\n   */\n  async getUserLPBalance(user: string, pool: string): Promise<JSBI> {\n    return this.dataProvider.getUserLPBalance(user, pool)\n  }\n\n  /**\n   * Get paginated list of user's LP positions with detailed information\n   */\n  async getUserLPPositions(user: string, offset: JSBI, limit: JSBI): Promise<LPPositionsResult> {\n    invariant(JSBI.greaterThanOrEqual(offset, JSBI.BigInt(0)), 'INVALID_OFFSET')\n    invariant(JSBI.greaterThan(limit, JSBI.BigInt(0)), 'INVALID_LIMIT')\n\n    return this.dataProvider.getUserLPPositions(user, offset, limit)\n  }\n\n  /**\n   * Check if user has any LP position in a specific pool\n   */\n  async hasLPPosition(user: string, pool: string): Promise<boolean> {\n    return this.dataProvider.hasLPPosition(user, pool)\n  }\n\n  /**\n   * Get all user's LP positions (no pagination)\n   */\n  async getAllUserLPPositions(user: string): Promise<LPPosition[]> {\n    const positions: LPPosition[] = []\n    let offset = JSBI.BigInt(0)\n    const limit = JSBI.BigInt(50) // Reasonable batch size\n\n    while (true) {\n      const result = await this.getUserLPPositions(user, offset, limit)\n      positions.push(...result.positions)\n\n      if (!result.hasMore) {\n        break\n      }\n\n      offset = JSBI.add(offset, limit)\n    }\n\n    return positions\n  }\n\n  /**\n   * Get total value locked (TVL) by user across all positions\n   */\n  async getUserTotalLPValue(\n    user: string\n  ): Promise<{\n    totalPositions: number\n    totalPools: number\n  }> {\n    const positions = await this.getAllUserLPPositions(user)\n    const pools = new Set(positions.map(p => p.pool))\n\n    return {\n      totalPositions: positions.length,\n      totalPools: pools.size\n    }\n  }\n}\n","import { Token } from './entities/token'\nimport { Currency } from './entities/currency'\nimport { CurrencyAmount } from './entities/fractions/currencyAmount'\nimport { Percent } from './entities/fractions/percent'\nimport { TradeType } from './constants'\nimport { validateAndParseAddress } from './utils/validateAndParseAddress'\nimport { Trade } from './entities'\nimport invariant from 'tiny-invariant'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Uniswap V2 Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Uniswap V2 Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount<Currency>) {\n  return `0x${currencyAmount.quotient.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Uniswap V2 Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trade: Trade<Currency, Currency, TradeType>,\n    options: TradeOptions | TradeOptionsDeadline\n  ): SwapParameters {\n    const etherIn = trade.inputAmount.currency.isNative\n    const etherOut = trade.outputAmount.currency.isNative\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token: Token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value\n    }\n  }\n}\n"],"names":["TradeType","Rounding","ENV","NODE_ENV","process","NETWORK","env","FACTORY_ADDRESS","ROUTER_ADDRESS","CHAIN_ID","parseInt","FACTORY_ADDRESSES","1","3","11155111","ROUTER_ADDRESSES","MaxUint256","JSBI","BigInt","FACTORY_ADDRESS_MAP","INIT_CODE_HASH","MINIMUM_LIQUIDITY","ZERO","ONE","FIVE","_997","_1000","BASIS_POINTS","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","_toSignificantRoundin","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","_toFixedRounding","Fraction","numerator","denominator","this","tryParseFraction","fractionish","Error","_proto","prototype","invert","add","other","otherParsed","equal","multiply","subtract","lessThan","equalTo","greaterThan","divide","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","invariant","set","precision","quotient","toString","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","_createClass","key","get","remainder","ONE_HUNDRED","toPercent","fraction","Percent","ChainId","_Fraction","_this","_inheritsLoose","call","ZERO_PERCENT","ONE_HUNDRED_PERCENT","SUPPORTED_CHAINS","MAINNET","ROPSTEN","SEPOLIA","BASE","NativeCurrencyName","CurrencyAmount","currency","lessThanOrEqual","decimalScale","exponentiate","decimals","fromRawAmount","rawAmount","fromFractionalAmount","equals","added","subtracted","multiplied","divided","toExact","isToken","wrapped","Price","baseCurrency","quoteCurrency","_len","arguments","length","args","Array","_key","result","quoteAmount","baseAmount","_ref","scalar","quote","currencyAmount","adjustedForDecimals","BaseCurrency","chainId","symbol","name","isSafeInteger","NativeCurrency","_BaseCurrency","validateAndParseAddress","address","getAddress","error","startsWith0xLen42HexRegex","checkValidAddress","test","Token","bypassChecksum","buyFeeBps","sellFeeBps","gte","BigNumber","from","toLowerCase","sortsBefore","WETH9","_WETH","Ether","_NativeCurrency","onChain","_this$_etherCache$cha","_etherCache","isNative","weth9","MAX_SAFE_INTEGER","TWO","sqrt","value","greaterThanOrEqual","Math","floor","toNumber","z","x","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","_Error","constructor","setPrototypeOf","_wrapNativeSuper","InsufficientInputAmountError","_Error2","_this2","computePairAddress","factoryAddress","tokenA","tokenB","_ref2","getCreate2Address","keccak256","pack","Pair","currencyAmountA","tokenAmountB","tokenAmounts","liquidityToken","involvesToken","token","token0","token1","priceOf","token0Price","token1Price","reserveOf","reserve0","reserve1","getOutputAmount","inputAmount","calculateFotFees","inputReserve","outputReserve","percentAfterSellFees","derivePercentAfterSellFees","inputAmountAfterTax","inputAmountWithFeeAndAfterTax","outputAmount","percentAfterBuyFees","derivePercentAfterBuyFees","outputAmountAfterTax","getInputAmount","outputAmountBeforeTax","getLiquidityMinted","totalSupply","tokenAmountA","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","sellFeeBips","gt","Route","pairs","input","output","every","pair","wrappedInput","_step","path","_iterator","_createForOfIteratorHelperLoose","entries","done","_step$value","currentInput","push","_midPrice","_step2","prices","_iterator2","_step2$value","reduced","slice","reduce","accumulator","currentValue","computePriceImpact","midPrice","quotedOutputAmount","priceImpact","sortedInsert","items","maxSize","comparator","isFull","lo","hi","mid","splice","pop","inputOutputComparator","a","b","tradeComparator","ioComp","route","Trade","amount","tradeType","EXACT_INPUT","i","_pair$getOutputAmount","_pair$getInputAmount","executionPrice","exactIn","amountIn","exactOut","amountOut","EXACT_OUTPUT","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","_temp","currentPairs","nextAmountIn","bestTrades","_ref$maxNumResults","maxNumResults","_ref$maxHops","maxHops","tokenOut","isInsufficientInputAmountError","concat","pairsExcludingThisPair","worstExecutionPrice","bestTradeExactOut","currencyIn","currencyAmountOut","_temp2","nextAmountOut","_ref2$maxNumResults","_ref2$maxHops","tokenIn","isInsufficientReservesError","sortTokens","getAmountOut","reserveIn","reserveOut","amountInWithFee","getAmountIn","computeProfitMaximizingTrade","truePriceTokenA","truePriceTokenB","reserveA","reserveB","currentPrice","aToB","invariantValue","leftSide","rightSide","getReservesAfterArbitrage","_computeProfitMaximiz","computeLiquidityValue","reservesA","reservesB","liquidityAmount","adjustedTotalSupply","numerator1","numerator2","MockLPDataProvider","Map","addMockUserPosition","user","pool","balance","userPools","has","Set","userBalances","addMockPoolData","poolData","getUserLPPoolCount","_getUserLPPoolCount","_asyncToGenerator","_regenerator","m","_callee","pools","w","_context","n","size","_x","apply","getUserLPPools","_getUserLPPools","_callee2","offset","limit","poolArray","offsetNum","limitNum","sliced","_context2","hasMore","_x2","_x3","_x4","getUserLPBalance","_getUserLPBalance","_callee3","_context3","_x5","_x6","getUserLPPositions","_getUserLPPositions","_callee4","poolsResult","positions","poolInfo","sharePercentage","_context4","v","getPoolInfo","_x7","_x8","_x9","hasLPPosition","_hasLPPosition","_callee5","_context5","_x0","_x1","_getPoolInfo","_callee6","info","_context6","_x10","LPPositionTracker","dataProvider","_proto2","_getUserLPPoolCount2","_callee7","_context7","_x11","_getUserLPPools2","_callee8","_context8","_x12","_x13","_x14","_getUserLPBalance2","_callee9","_context9","_x15","_x16","_getUserLPPositions2","_callee0","_context0","_x17","_x18","_x19","_hasLPPosition2","_callee1","_context1","_x20","_x21","getAllUserLPPositions","_getAllUserLPPositions","_callee10","_context10","_x22","getUserTotalLPValue","_getUserTotalLPValue","_callee11","_context11","map","p","totalPositions","totalPools","_x23","toHex","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","to","recipient","allowedSlippage","deadline","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","reserves","amounts","pairReserves","_getReservesAfterArbi","factory","initCodeHash","_sortTokens","padStart","amountA"],"mappings":"8IAOYA,EAKAC,sPCXCC,EAAM,CACjBC,SAAUC,aACVC,QAASD,QAAQE,IAAID,SAAW,UAChCE,gBAAiBH,QAAQE,IAAIC,gBAC7BC,eAAgBJ,QAAQE,IAAIE,eAC5BC,SAAUL,QAAQE,IAAIG,SAAWC,SAASN,QAAQE,IAAIG,UAAY,GCHvDE,EAAmD,CAC9DC,EAAG,6CACHC,EAAG,6CACHC,SAAU,8CAGCC,EAAkD,CAC7DH,EAAG,6CACHC,EAAG,6CACHC,SAAU,8CAIRZ,EAAIK,iBAAmBL,EAAIO,WAC7BE,EAAkBT,EAAIO,UAAYP,EAAIK,iBAGpCL,EAAIM,gBAAkBN,EAAIO,WAC5BM,EAAiBb,EAAIO,UAAYP,EAAIM,iBFd3BR,EAAAA,oBAAAA,sDAEVA,oCAGUC,EAAAA,mBAAAA,mDAEVA,qCACAA,2BAGF,QAAae,EAAaC,EAAKC,OAAO,sEAEzBC,EAAqDR,EAErDS,EAAiB,qEAEjBC,EAAoBJ,EAAKC,OAAO,KAGhCI,EAAOL,EAAKC,OAAO,GACnBK,EAAMN,EAAKC,OAAO,GAClBM,EAAOP,EAAKC,OAAO,GACnBO,EAAOR,EAAKC,OAAO,KACnBQ,EAAQT,EAAKC,OAAO,KACpBS,EAAeV,EAAKC,OAAO,q1JGxBxC,IAAMU,EAAUC,EAASC,GACnBC,EAAMF,EAASG,GAEfC,IAAqBC,MACxBjC,iBAASkC,YAAaP,EAAQO,WAAUD,EACxCjC,iBAASmC,eAAgBR,EAAQQ,cAAaF,EAC9CjC,iBAASoC,UAAWT,EAAQS,SAAQH,GAGjCI,IAAeC,MAClBtC,iBAASkC,gBACTlC,iBAASmC,mBACTnC,iBAASoC,eAGCG,aAIX,SAAAA,EAAmBC,EAAsBC,YAAAA,IAAAA,EAAyBzB,EAAKC,OAAO,IAC5EyB,KAAKF,UAAYxB,EAAKC,OAAOuB,GAC7BE,KAAKD,YAAczB,EAAKC,OAAOwB,GAChCF,EAEcI,iBAAP,SAAwBC,GAC9B,GAAIA,aAAuB5B,GAA+B,iBAAhB4B,GAAmD,iBAAhBA,EAC3E,OAAO,IAAIL,EAASK,GAEtB,GAAI,cAAeA,GAAe,gBAAiBA,EAAa,OAAOA,EACvE,MAAM,IAAIC,MAAM,6BAGlB,IAAAC,EAAAP,EAAAQ,UA8GA,OA9GAD,EAUOE,OAAA,WACL,OAAO,IAAIT,EAASG,KAAKD,YAAaC,KAAKF,YAC5CM,EAEMG,IAAA,SAAIC,GACT,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAIlC,EAAKoC,MAAMV,KAAKD,YAAaU,EAAYV,aACpC,IAAIF,EAASvB,EAAKiC,IAAIP,KAAKF,UAAWW,EAAYX,WAAYE,KAAKD,aAErE,IAAIF,EACTvB,EAAKiC,IACHjC,EAAKqC,SAASX,KAAKF,UAAWW,EAAYV,aAC1CzB,EAAKqC,SAASF,EAAYX,UAAWE,KAAKD,cAE5CzB,EAAKqC,SAASX,KAAKD,YAAaU,EAAYV,eAE/CK,EAEMQ,SAAA,SAASJ,GACd,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAIlC,EAAKoC,MAAMV,KAAKD,YAAaU,EAAYV,aACpC,IAAIF,EAASvB,EAAKsC,SAASZ,KAAKF,UAAWW,EAAYX,WAAYE,KAAKD,aAE1E,IAAIF,EACTvB,EAAKsC,SACHtC,EAAKqC,SAASX,KAAKF,UAAWW,EAAYV,aAC1CzB,EAAKqC,SAASF,EAAYX,UAAWE,KAAKD,cAE5CzB,EAAKqC,SAASX,KAAKD,YAAaU,EAAYV,eAE/CK,EAEMS,SAAA,SAASL,GACd,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAOlC,EAAKuC,SACVvC,EAAKqC,SAASX,KAAKF,UAAWW,EAAYV,aAC1CzB,EAAKqC,SAASF,EAAYX,UAAWE,KAAKD,eAE7CK,EAEMU,QAAA,SAAQN,GACb,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAOlC,EAAKoC,MACVpC,EAAKqC,SAASX,KAAKF,UAAWW,EAAYV,aAC1CzB,EAAKqC,SAASF,EAAYX,UAAWE,KAAKD,eAE7CK,EAEMW,YAAA,SAAYP,GACjB,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAOlC,EAAKyC,YACVzC,EAAKqC,SAASX,KAAKF,UAAWW,EAAYV,aAC1CzB,EAAKqC,SAASF,EAAYX,UAAWE,KAAKD,eAE7CK,EAEMO,SAAA,SAASH,GACd,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAO,IAAIX,EACTvB,EAAKqC,SAASX,KAAKF,UAAWW,EAAYX,WAC1CxB,EAAKqC,SAASX,KAAKD,YAAaU,EAAYV,eAE/CK,EAEMY,OAAA,SAAOR,GACZ,IAAMC,EAAcZ,EAASI,iBAAiBO,GAC9C,OAAO,IAAIX,EACTvB,EAAKqC,SAASX,KAAKF,UAAWW,EAAYV,aAC1CzB,EAAKqC,SAASX,KAAKD,YAAaU,EAAYX,aAE/CM,EAEMa,cAAA,SACLC,EACAC,EACAC,YADAD,IAAAA,EAAiB,CAAEE,eAAgB,cACnCD,IAAAA,EAAqB9D,iBAASmC,eAEpB6B,OAAOC,UAAUL,IAA3BM,MACUN,EAAoB,GAA9BM,MAEAvC,EAAQwC,IAAI,CAAEC,UAAWR,EAAoB,EAAGE,SAAU9B,EAAsB8B,KAChF,IAAMO,EAAW,IAAI1C,EAAQe,KAAKF,UAAU8B,YACzCC,IAAI7B,KAAKD,YAAY6B,YACrBE,oBAAoBZ,GACvB,OAAOS,EAASzC,SAASyC,EAASI,gBAAiBZ,IACpDf,EAEM4B,QAAA,SACLD,EACAZ,EACAC,GAOA,gBARAD,IAAAA,EAAiB,CAAEE,eAAgB,cACnCD,IAAAA,EAAqB9D,iBAASmC,eAEpB6B,OAAOC,UAAUQ,IAA3BP,MACUO,GAAiB,GAA3BP,MAEApC,EAAI6C,GAAKF,EACT3C,EAAI8C,GAAKvC,EAAgByB,GAClB,IAAIhC,EAAIY,KAAKF,UAAU8B,YAAYC,IAAI7B,KAAKD,YAAY6B,YAAY1C,SAAS6C,EAAeZ,IAGrGgB,EAAAtC,IAAAuC,eAAAC,IA7GA,WACE,OAAO/D,EAAK0C,OAAOhB,KAAKF,UAAWE,KAAKD,gBAG1CqC,gBAAAC,IACA,WACE,OAAO,IAAIxC,EAASvB,EAAKgE,UAAUtC,KAAKF,UAAWE,KAAKD,aAAcC,KAAKD,gBAC5EqC,iBAAAC,IAyGD,WACE,OAAO,IAAIxC,EAASG,KAAKF,UAAWE,KAAKD,oBCtJvCwC,EAAc,IAAI1C,EAASvB,EAAKC,OAAO,MAM7C,SAASiE,EAAUC,GACjB,OAAO,IAAIC,EAAQD,EAAS3C,UAAW2C,EAAS1C,iBCXtC4C,EDcCD,WAAQE,GAArB,SAAAF,UAIwC,mDAAJ,EAAIG,EAyBvCC,EAAAJ,EAAAE,GAAA,IAAAxC,EAAAsC,EAAArC,UADE,OACFD,EAvBCG,IAAA,SAAIC,GACF,OAAOgC,EAASI,EAAAvC,UAAOE,IAAGwC,UAACvC,KAC5BJ,EAEDQ,SAAA,SAASJ,GACP,OAAOgC,EAASI,EAAAvC,UAAOO,SAAQmC,UAACvC,KACjCJ,EAEDO,SAAA,SAASH,GACP,OAAOgC,EAASI,EAAAvC,UAAOM,SAAQoC,UAACvC,KACjCJ,EAEDY,OAAA,SAAOR,GACL,OAAOgC,EAASI,EAAAvC,UAAOW,OAAM+B,UAACvC,KAC/BJ,EAEMa,cAAA,SAAcC,EAA+BC,EAAiBC,GACnE,gBADmBF,IAAAA,EAA4B,GACxC0B,EAAAvC,UAAMM,SAAQoC,UAACR,GAAatB,cAAcC,EAAmBC,EAAQC,IAC7EhB,EAEM4B,QAAA,SAAQD,EAA2BZ,EAAiBC,GACzD,gBADaW,IAAAA,EAAwB,GAC9Ba,EAAAvC,UAAMM,SAAQoC,UAACR,GAAaP,QAAQD,EAAeZ,EAAQC,IACnEsB,GA5B0B7C,GA+BhBmD,EAAe,IAAIN,EAAQ/D,GAC3BsE,EAAsB,IAAIP,EAAQ9D,IC9CnC+D,EAAAA,kBAAAA,4CAEVA,yBACAA,gCACAA,sBAGF,IAAaO,EAAmB,CAACP,gBAAQQ,QAASR,gBAAQS,QAAST,gBAAQU,QAASV,gBAAQW,OAGhFC,6BAAAA,4CCAZ,IAAMnE,EAAMF,EAASG,GAERmE,YAAmCZ,GA2B9C,SAAAY,EAAsBC,EAAa3D,EAAsBC,SAI+B,OAHtF8C,EAAAD,EAAAG,UAAMjD,EAAWC,SACPzB,EAAKoF,gBAAgBb,EAAKlB,SAAUtD,IAA9CmD,MACAqB,EAAKY,SAAWA,EAChBZ,EAAKc,aAAerF,EAAKsF,aAAatF,EAAKC,OAAO,IAAKD,EAAKC,OAAOkF,EAASI,WAAUhB,EA3BxFC,EAAAU,EAAAZ,GAAAY,EAKcM,cAAP,SAAyCL,EAAaM,GAC3D,OAAO,IAAIP,EAAeC,EAAUM,IAGtCP,EAMcQ,qBAAP,SACLP,EACA3D,EACAC,GAEA,OAAO,IAAIyD,EAAeC,EAAU3D,EAAWC,IAChD,IAAAK,EAAAoD,EAAAnD,UAmDA,OAnDAD,EASMG,IAAA,SAAIC,GACCR,KAAKyD,SAASQ,OAAOzD,EAAMiD,WAArCjC,MACA,IAAM0C,EAAKtB,EAAAvC,UAASE,IAAGwC,UAACvC,GACxB,OAAOgD,EAAeQ,qBAAqBhE,KAAKyD,SAAUS,EAAMpE,UAAWoE,EAAMnE,cAClFK,EAEMQ,SAAA,SAASJ,GACJR,KAAKyD,SAASQ,OAAOzD,EAAMiD,WAArCjC,MACA,IAAM2C,EAAUvB,EAAAvC,UAASO,SAAQmC,UAACvC,GAClC,OAAOgD,EAAeQ,qBAAqBhE,KAAKyD,SAAUU,EAAWrE,UAAWqE,EAAWpE,cAC5FK,EAEMO,SAAA,SAASH,GACd,IAAM4D,EAAUxB,EAAAvC,UAASM,SAAQoC,UAACvC,GAClC,OAAOgD,EAAeQ,qBAAqBhE,KAAKyD,SAAUW,EAAWtE,UAAWsE,EAAWrE,cAC5FK,EAEMY,OAAA,SAAOR,GACZ,IAAM6D,EAAOzB,EAAAvC,UAASW,OAAM+B,UAACvC,GAC7B,OAAOgD,EAAeQ,qBAAqBhE,KAAKyD,SAAUY,EAAQvE,UAAWuE,EAAQtE,cACtFK,EAEMa,cAAA,SACLC,EACAC,EACAC,GAEA,gBAJAF,IAAAA,EAA4B,YAE5BE,IAAAA,EAAqB9D,iBAASkC,YAEvBoD,EAAAvC,UAAMW,OAAM+B,UAAC/C,KAAK2D,cAAc1C,cAAcC,EAAmBC,EAAQC,IACjFhB,EAEM4B,QAAA,SACLD,EACAZ,EACAC,GAGA,gBALAW,IAAAA,EAAwB/B,KAAKyD,SAASI,mBAEtCzC,IAAAA,EAAqB9D,iBAASkC,YAEpBuC,GAAiB/B,KAAKyD,SAASI,UAAzCrC,MACOoB,EAAAvC,UAAMW,OAAM+B,UAAC/C,KAAK2D,cAAc3B,QAAQD,EAAeZ,EAAQC,IACvEhB,EAEMkE,QAAA,SAAQnD,GAEb,gBAFaA,IAAAA,EAAiB,CAAEE,eAAgB,KAChDjC,EAAI6C,GAAKjC,KAAKyD,SAASI,SAChB,IAAIzE,EAAIY,KAAK2B,SAASC,YAAYC,IAAI7B,KAAK2D,aAAa/B,YAAY1C,SAASiC,IACrFgB,EAAAqB,IAAApB,cAAAC,IAED,WACE,OAAIrC,KAAKyD,SAASc,QAAgBvE,KAC3BwD,EAAeQ,qBAAqBhE,KAAKyD,SAASe,QAASxE,KAAKF,UAAWE,KAAKD,kBAhFnCF,GCJ3C4E,YAAuD7B,GASlE,SAAA6B,IAK8F,UAAxFC,EAAqBC,EAAuB5E,EAAwBD,EAAoB8E,EAAAC,UAAAC,OAJzFC,MAE6EC,MAAAJ,GAAAK,IAAAA,EAAAL,EAAAK,IAF7EF,EAE6EE,GAAAJ,UAAAI,GAIhF,GAAoB,IAAhBF,EAAKD,OACLJ,EAAuDK,KAAzCJ,EAAyCI,KAA1BhF,EAA0BgF,KAAbjF,EAAaiF,SACpD,CACL,IAAMG,EAASH,EAAK,GAAGI,YAAYnE,OAAO+D,EAAK,GAAGK,YACjDC,EAAwD,CACvDN,EAAK,GAAGK,WAAW3B,SACnBsB,EAAK,GAAGI,YAAY1B,SACpByB,EAAOnF,YACPmF,EAAOpF,WAJP4E,EAAYW,KAAEV,EAAaU,KAAEtF,EAAWsF,KAAEvF,EAASuF,KActD,OAPDxC,EAAAD,EAAAG,UAAMjD,EAAWC,UAEZ2E,aAAeA,EACpB7B,EAAK8B,cAAgBA,EACrB9B,EAAKyC,OAAS,IAAIzF,EAChBvB,EAAKsF,aAAatF,EAAKC,OAAO,IAAKD,EAAKC,OAAOmG,EAAab,WAC5DvF,EAAKsF,aAAatF,EAAKC,OAAO,IAAKD,EAAKC,OAAOoG,EAAcd,YAC9DhB,EAGHC,EAAA2B,EAAA7B,GAAA,IAAAxC,EAAAqE,EAAApE,UAyCC,OAzCDD,EAGOE,OAAA,WACL,OAAO,IAAImE,EAAMzE,KAAK2E,cAAe3E,KAAK0E,aAAc1E,KAAKF,UAAWE,KAAKD,cAG/EK,EAIOO,SAAA,SAAuCH,GAClCR,KAAK2E,cAAcV,OAAOzD,EAAMkE,eAA1ClD,MACA,IAAMiB,EAAQG,EAAAvC,UAASM,SAAQoC,UAACvC,GAChC,OAAO,IAAIiE,EAAMzE,KAAK0E,aAAclE,EAAMmE,cAAelC,EAAS1C,YAAa0C,EAAS3C,YAG1FM,EAIOmF,MAAA,SAAMC,GACDA,EAAe/B,SAASQ,OAAOjE,KAAK0E,eAA9ClD,MACA,IAAM0D,EAAMtC,EAAAvC,UAASM,SAAQoC,UAACyC,GAC9B,OAAOhC,GAAeQ,qBAAqBhE,KAAK2E,cAAeO,EAAOpF,UAAWoF,EAAOnF,cAG1FK,EAQOa,cAAA,SAAcC,EAA+BC,EAAiBC,GACnE,gBADmBF,IAAAA,EAA4B,GACxClB,KAAKyF,oBAAoBxE,cAAcC,EAAmBC,EAAQC,IAC1EhB,EAEM4B,QAAA,SAAQD,EAA2BZ,EAAiBC,GACzD,gBADaW,IAAAA,EAAwB,GAC9B/B,KAAKyF,oBAAoBzD,QAAQD,EAAeZ,EAAQC,IAChEe,EAAAsC,IAAArC,0BAAAC,IAVD,WACE,OAAAO,EAAAvC,UAAaM,SAAQoC,UAAC/C,KAAKsF,aArE6CzF,GCDtD6F,GAkCpB,SAAsBC,EAAiB9B,EAAkB+B,EAAiBC,GAC9DvE,OAAOwE,cAAcH,IAA/BnE,MACUqC,GAAY,GAAKA,EAAW,KAAOvC,OAAOC,UAAUsC,IAA9DrC,MAEAxB,KAAK2F,QAAUA,EACf3F,KAAK6D,SAAWA,EAChB7D,KAAK4F,OAASA,EACd5F,KAAK6F,KAAOA,GC3CME,YAAeC,GAArC,SAAAD,UAEwC,kDADL,EACjBlD,WAAiB,EAAKA,EACvC,OAAAC,EAAAiD,EAAAC,GAAAD,GAH4CL,aCC7BO,GAAwBC,GACtC,IACE,OAAOC,aAAWD,GAClB,MAAOE,GACP,MAAM,IAAIjG,MAAS+F,+BAKvB,IAAMG,GAA4B,+BAMlBC,GAAkBJ,GAChC,GAAIG,GAA0BE,KAAKL,GACjC,OAAOA,EAGT,MAAM,IAAI/F,MAAS+F,qCCjBRM,YAAMR,GA2BjB,SAAAQ,EACEb,EACAO,EACArC,EACA+B,EACAC,EACAY,EACAC,EACAC,SAe4B,OAb5B9D,EAAAmD,EAAAjD,UAAM4C,EAAS9B,EAAU+B,EAAQC,oBApCD,EAClBhD,WAAgB,EAqC5BA,EAAKqD,QADHO,EACaH,GAAkBJ,GAElBD,GAAwBC,GAErCQ,IACQA,EAAUE,IAAIC,YAAUC,KAAK,KAAvCtF,OAEEmF,IACQA,EAAWC,IAAIC,YAAUC,KAAK,KAAxCtF,OAEFqB,EAAK6D,UAAYA,EACjB7D,EAAK8D,WAAaA,EAAU9D,EAG9BC,EAAA0D,EAAAR,GAAA,IAAA5F,EAAAoG,EAAAnG,UAoBA,OApBAD,EAIO6D,OAAA,SAAOzD,GACZ,OAAOA,EAAM+D,SAAWvE,KAAK2F,UAAYnF,EAAMmF,SAAW3F,KAAKkG,QAAQa,gBAAkBvG,EAAM0F,QAAQa,eAGzG3G,EAMO4G,YAAA,SAAYxG,GAGjB,OAFUR,KAAK2F,UAAYnF,EAAMmF,SAAjCnE,MACUxB,KAAKkG,QAAQa,gBAAkBvG,EAAM0F,QAAQa,eAAvDvF,MACOxB,KAAKkG,QAAQa,cAAgBvG,EAAM0F,QAAQa,eAGpD5E,EAAAqE,IAAApE,cAAAC,IAGA,WACE,OAAOrC,UA7EgB0F,ICHduB,KAAKC,OACfvE,gBAAQQ,SAAU,IAAIqD,GACrB7D,gBAAQQ,QACR,6CACA,GACA,OACA,iBACD+D,GACAvE,gBAAQS,SAAU,IAAIoD,GACrB7D,gBAAQS,QACR,6CACA,GACA,OACA,iBACD8D,GACAvE,gBAAQU,SAAU,IAAImD,GACrB7D,gBAAQU,QACR,6CACA,GACA,OACA,iBACD6D,GACAvE,gBAAQW,MAAO,IAAIkD,GAAM7D,gBAAQW,KAAM,6CAA8C,GAAI,OAAQ,iBAAgB4D,ICnBvGC,YAAMC,GACjB,SAAAD,EAAsBxB,UACpByB,EAAArE,UAAM4C,EAAS,GAAI,MAAO,eAiB3B,OAhBA7C,EAAAqE,EAAAC,GAAAD,EAUaE,QAAP,SAAe1B,SACpB,cAAA2B,EAAOtH,KAAKuH,YAAY5B,IAAQ2B,EAAKtH,KAAKuH,YAAY5B,GAAW,IAAIwB,EAAMxB,IAC5EwB,EAAA9G,UAEM4D,OAAA,SAAOzD,GACZ,OAAOA,EAAMgH,UAAYhH,EAAMmF,UAAY3F,KAAK2F,SACjDxD,EAAAgF,IAAA/E,cAAAC,IAdD,WACE,IAAMoF,EAAQR,GAAMjH,KAAK2F,SAEzB,OADY8B,GAAZjG,MACOiG,OARgB1B,IAWVoB,eAA4C,OCjBhDO,GAAmBpJ,EAAKC,OAAO+C,OAAOoG,kBAE7C/I,GAAOL,EAAKC,OAAO,GACnBK,GAAMN,EAAKC,OAAO,GAClBoJ,GAAMrJ,EAAKC,OAAO,YAMRqJ,GAAKC,GAInB,GAHUvJ,EAAKwJ,mBAAmBD,EAAOlJ,KAAzC6C,MAGIlD,EAAKuC,SAASgH,EAAOH,IACvB,OAAOpJ,EAAKC,OAAOwJ,KAAKC,MAAMD,KAAKH,KAAKtJ,EAAK2J,SAASJ,MAGxD,IAAIK,EACAC,EAGJ,IAFAD,EAAIL,EACJM,EAAI7J,EAAKiC,IAAIjC,EAAK0C,OAAO6G,EAAOF,IAAM/I,IAC/BN,EAAKuC,SAASsH,EAAGD,IACtBA,EAAIC,EACJA,EAAI7J,EAAK0C,OAAO1C,EAAKiC,IAAIjC,EAAK0C,OAAO6G,EAAOM,GAAIA,GAAIR,IAEtD,OAAOO,EC5BT,IAAME,GAAoB,mBAAoBC,OAMjCC,YAA0BC,GAGrC,SAAAD,UAG0E,OAFxEzF,EAAA0F,EAAAxF,+CAHkD,EAIlDF,EAAKgD,KAAOhD,EAAK2F,YAAY3C,KACzBuC,IAAmBC,OAAOI,eAAc5F,mBAAOyF,OAAAE,oBAAWnI,WAAUwC,EACzE,OAAAC,EAAAwF,EAAAC,GAAAD,GAAAI,EAP4CvI,QAclCwI,YAA6BC,GAGxC,SAAAD,UAG0E,OAFxEE,EAAAD,EAAA7F,kDAHqD,EAIrD8F,EAAKhD,KAAOgD,EAAKL,YAAY3C,KACzBuC,IAAmBC,OAAOI,eAAcI,mBAAOF,OAAAH,oBAAWnI,WAAUwI,EACzE,OAAA/F,EAAA6F,EAAAC,GAAAD,GAAAD,EAP+CvI,QCKrC2I,GAAqB,SAAHzD,OAC7B0D,EAAc1D,EAAd0D,eACAC,EAAM3D,EAAN2D,OACAC,EAAM5D,EAAN4D,OAMAC,EAAyBF,EAAOhC,YAAYiC,GAAU,CAACD,EAAQC,GAAU,CAACA,EAAQD,GAClF,OAAOG,oBACLJ,EACAK,YAAU,CAAC,SAAU,CAACC,OAAK,CAAC,UAAW,WAAY,CAHxCH,KAGgDhD,QAHxCgD,KAGwDhD,YAC3EzH,IAGS6K,cAUX,SAAAA,EAAmBC,EAAwCC,GACzD,IAAMC,EAAeF,EAAgB9F,SAASuD,YAAYwC,EAAa/F,UACnE,CAAC8F,EAAiBC,GAClB,CAACA,EAAcD,GACnBvJ,KAAK0J,eAAiB,IAAIlD,GACxBiD,EAAa,GAAGhG,SAASkC,QACzB2D,EAAKnD,WAAWsD,EAAa,GAAGhG,SAAUgG,EAAa,GAAGhG,UAC1D,GACA,SACA,cAEFzD,KAAKyJ,aAAeA,EACrBH,EAlBanD,WAAP,SAAkB6C,EAAeC,GACtC,IAAMF,EAAiBvK,EAAoBwK,EAAOrD,SAElD,OADUoD,GAAVvH,MACOsH,GAAmB,CAAEC,eAAAA,EAAgBC,OAAAA,EAAQC,OAAAA,KAiBtD,IAAA7I,EAAAkJ,EAAAjJ,UAqVC,OArVDD,EAIOuJ,cAAA,SAAcC,GACnB,OAAOA,EAAM3F,OAAOjE,KAAK6J,SAAWD,EAAM3F,OAAOjE,KAAK8J,SAmBxD1J,EAIO2J,QAAA,SAAQH,GAEb,OADU5J,KAAK2J,cAAcC,IAA7BpI,MACOoI,EAAM3F,OAAOjE,KAAK6J,QAAU7J,KAAKgK,YAAchK,KAAKiK,aAG7D7J,EAuBO8J,UAAA,SAAUN,GAEf,OADU5J,KAAK2J,cAAcC,IAA7BpI,MACOoI,EAAM3F,OAAOjE,KAAK6J,QAAU7J,KAAKmK,SAAWnK,KAAKoK,UAG1DhK,EA4DOiK,gBAAA,SACLC,EACAC,GAGA,YAHAA,IAAAA,GAA4B,GAElBvK,KAAK2J,cAAcW,EAAY7G,WAAzCjC,MACIlD,EAAKoC,MAAMV,KAAKmK,SAASxI,SAAUhD,IAASL,EAAKoC,MAAMV,KAAKoK,SAASzI,SAAUhD,GACjF,MAAM,IAAI2J,GAEZ,IAAMkC,EAAexK,KAAKkK,UAAUI,EAAY7G,UAC1CgH,EAAgBzK,KAAKkK,UAAUI,EAAY7G,SAASQ,OAAOjE,KAAK6J,QAAU7J,KAAK8J,OAAS9J,KAAK6J,QAE7Fa,EAAuBH,EAAmBvK,KAAK2K,2BAA2BL,GAAetH,EACzF4H,EAAsBF,EAAqB3J,YAAYiC,GACzDQ,GAAeM,cACbwG,EAAY7G,SACZiH,EAAqB/J,SAAS2J,GAAa3I,UAE7C2I,EAEEO,EAAgCvM,EAAKqC,SAASiK,EAAoBjJ,SAAU7C,GAC5EgB,EAAYxB,EAAKqC,SAASkK,EAA+BJ,EAAc9I,UACvE5B,EAAczB,EAAKiC,IAAIjC,EAAKqC,SAAS6J,EAAa7I,SAAU5C,GAAQ8L,GACpEC,EAAetH,GAAeM,cAClCwG,EAAY7G,SAASQ,OAAOjE,KAAK6J,QAAU7J,KAAK8J,OAAS9J,KAAK6J,OAC9DvL,EAAK0C,OAAOlB,EAAWC,IAGzB,GAAIzB,EAAKoC,MAAMoK,EAAanJ,SAAUhD,GACpC,MAAM,IAAIgK,GAGZ,IAAMoC,EAAsBR,EAAmBvK,KAAKgL,0BAA0BF,GAAgB9H,EACxFiI,EAAuBF,EAAoBhK,YAAYiC,GACzDQ,GAAeM,cACbgH,EAAarH,SACbqH,EAAanK,SAASoK,GAAqBpJ,UAE7CmJ,EACJ,GAAIxM,EAAKoC,MAAMuK,EAAqBtJ,SAAUhD,GAC5C,MAAM,IAAIgK,GAGZ,MAAO,CACLsC,EACA,IAAI3B,EAAKkB,EAAajK,IAAIqK,GAAsBH,EAAc7J,SAASqK,MAI3E7K,EA0CO8K,eAAA,SACLJ,EACAP,YAAAA,IAAAA,GAA4B,GAElBvK,KAAK2J,cAAcmB,EAAarH,WAA1CjC,MACA,IAAMuJ,EAAsBR,EAAmBvK,KAAKgL,0BAA0BF,GAAgB9H,EACxFmI,EAAwBJ,EAAoBhK,YAAYiC,GAC1DQ,GAAeM,cACbgH,EAAarH,SACbnF,EAAKiC,IAAIuK,EAAa9J,OAAO+J,GAAqBpJ,SAAU/C,IAE9DkM,EAEJ,GACExM,EAAKoC,MAAMV,KAAKmK,SAASxI,SAAUhD,IACnCL,EAAKoC,MAAMV,KAAKoK,SAASzI,SAAUhD,IACnCL,EAAKwJ,mBAAmBgD,EAAanJ,SAAU3B,KAAKkK,UAAUY,EAAarH,UAAU9B,WACrFrD,EAAKwJ,mBAAmBqD,EAAsBxJ,SAAU3B,KAAKkK,UAAUY,EAAarH,UAAU9B,UAE9F,MAAM,IAAI2G,GAGZ,IAAMmC,EAAgBzK,KAAKkK,UAAUY,EAAarH,UAC5C+G,EAAexK,KAAKkK,UAAUY,EAAarH,SAASQ,OAAOjE,KAAK6J,QAAU7J,KAAK8J,OAAS9J,KAAK6J,QAE7F/J,EAAYxB,EAAKqC,SAASrC,EAAKqC,SAAS6J,EAAa7I,SAAUwJ,EAAsBxJ,UAAW5C,GAChGgB,EAAczB,EAAKqC,SAASrC,EAAKsC,SAAS6J,EAAc9I,SAAUwJ,EAAsBxJ,UAAW7C,GACnGwL,EAAc9G,GAAeM,cACjCgH,EAAarH,SAASQ,OAAOjE,KAAK6J,QAAU7J,KAAK8J,OAAS9J,KAAK6J,OAC/DvL,EAAKiC,IAAIjC,EAAK0C,OAAOlB,EAAWC,GAAcnB,IAG1C8L,EAAuBH,EAAmBvK,KAAK2K,2BAA2BL,GAAetH,EAO/F,MAAO,CANsB0H,EAAqB3J,YAAYiC,GAC1DQ,GAAeM,cACbwG,EAAY7G,SACZnF,EAAKiC,IAAI+J,EAAYtJ,OAAO0J,GAAsB/I,SAAU/C,IAE9D0L,EAC0B,IAAIhB,EAAKkB,EAAajK,IAAI+J,GAAcG,EAAc7J,SAASkK,MAC9F1K,EAEMgL,mBAAA,SACLC,EACAC,EACA9B,GAEU6B,EAAY5H,SAASQ,OAAOjE,KAAK0J,iBAA3ClI,MACA,IAKI+J,EALE9B,EAAe6B,EAAa7H,SAASuD,YAAYwC,EAAa/F,UAChE,CAAC6H,EAAc9B,GACf,CAACA,EAAc8B,GAInB,GAHU7B,EAAa,GAAGhG,SAASQ,OAAOjE,KAAK6J,SAAWJ,EAAa,GAAGhG,SAASQ,OAAOjE,KAAK8J,SAA/FtI,MAGIlD,EAAKoC,MAAM2K,EAAY1J,SAAUhD,GACnC4M,EAAYjN,EAAKsC,SACfgH,GAAKtJ,EAAKqC,SAAS8I,EAAa,GAAG9H,SAAU8H,EAAa,GAAG9H,WAC7DjD,OAEG,CACL,IAAM8M,EAAUlN,EAAK0C,OAAO1C,EAAKqC,SAAS8I,EAAa,GAAG9H,SAAU0J,EAAY1J,UAAW3B,KAAKmK,SAASxI,UACnG8J,EAAUnN,EAAK0C,OAAO1C,EAAKqC,SAAS8I,EAAa,GAAG9H,SAAU0J,EAAY1J,UAAW3B,KAAKoK,SAASzI,UACzG4J,EAAYjN,EAAKoF,gBAAgB8H,EAASC,GAAWD,EAAUC,EAEjE,IAAKnN,EAAKyC,YAAYwK,EAAW5M,GAC/B,MAAM,IAAIgK,GAEZ,OAAOnF,GAAeM,cAAc9D,KAAK0J,eAAgB6B,IAC1DnL,EAEMsL,kBAAA,SACL9B,EACAyB,EACAE,EACAI,EACAC,GAOA,IAAIC,EACJ,YATAF,IAAAA,GAAiB,GAGP3L,KAAK2J,cAAcC,IAA7BpI,MACU6J,EAAY5H,SAASQ,OAAOjE,KAAK0J,iBAA3ClI,MACU+J,EAAU9H,SAASQ,OAAOjE,KAAK0J,iBAAzClI,MACUlD,EAAKoF,gBAAgB6H,EAAU5J,SAAU0J,EAAY1J,WAA/DH,MAGKmK,EAEE,CACOC,GAAZpK,MACA,IAAMsK,EAAcxN,EAAKC,OAAOqN,GAChC,GAAKtN,EAAKoC,MAAMoL,EAAanN,GAY3BkN,EAAsBR,MAZY,CAClC,IAAMU,EAAQnE,GAAKtJ,EAAKqC,SAASX,KAAKmK,SAASxI,SAAU3B,KAAKoK,SAASzI,WACjEqK,EAAYpE,GAAKkE,GACvB,GAAIxN,EAAKyC,YAAYgL,EAAOC,GAAY,CACtC,IAAMlM,EAAYxB,EAAKqC,SAAS0K,EAAY1J,SAAUrD,EAAKsC,SAASmL,EAAOC,IACrEjM,EAAczB,EAAKiC,IAAIjC,EAAKqC,SAASoL,EAAOlN,GAAOmN,GACnDC,EAAe3N,EAAK0C,OAAOlB,EAAWC,GAC5C8L,EAAsBR,EAAY9K,IAAIiD,GAAeM,cAAc9D,KAAK0J,eAAgBuC,SAExFJ,EAAsBR,QAb1BQ,EAAsBR,EAoBxB,OAAO7H,GAAeM,cACpB8F,EACAtL,EAAK0C,OAAO1C,EAAKqC,SAAS4K,EAAU5J,SAAU3B,KAAKkK,UAAUN,GAAOjI,UAAWkK,EAAoBlK,YAEtGvB,EAEOuK,2BAAA,SAA2BL,GACjC,IAAM4B,EAAclM,KAAK6J,OAAOrF,QAAQP,OAAOqG,EAAY9F,QAAQf,UAC/DzD,KAAK6J,OAAOrF,QAAQmC,WACpB3G,KAAK8J,OAAOtF,QAAQmC,WACxB,aAAIuF,GAAAA,EAAaC,GAAGtF,YAAUC,KAAK,IAC1B7D,EAAoBrC,SAAS,IAAI8B,EAAQpE,EAAKC,OAAO2N,IAAclL,OAAOhC,IAE1EgE,GAEV5C,EAEO4K,0BAAA,SAA0BF,GAChC,IAAMpE,EAAY1G,KAAK6J,OAAOrF,QAAQP,OAAO6G,EAAatG,QAAQf,UAC9DzD,KAAK6J,OAAOrF,QAAQkC,UACpB1G,KAAK8J,OAAOtF,QAAQkC,UACxB,aAAIA,GAAAA,EAAWyF,GAAGtF,YAAUC,KAAK,IACxB7D,EAAoBrC,SAAS,IAAI8B,EAAQpE,EAAKC,OAAOmI,IAAY1F,OAAOhC,IAExEgE,GAEVb,EAAAmH,IAAAlH,kBAAAC,IA1UD,WACE,IAAM6C,EAASlF,KAAKyJ,aAAa,GAAGzI,OAAOhB,KAAKyJ,aAAa,IAC7D,OAAO,IAAIhF,GAAMzE,KAAK6J,OAAQ7J,KAAK8J,OAAQ5E,EAAOnF,YAAamF,EAAOpF,cAGxEsC,kBAAAC,IAGA,WACE,IAAM6C,EAASlF,KAAKyJ,aAAa,GAAGzI,OAAOhB,KAAKyJ,aAAa,IAC7D,OAAO,IAAIhF,GAAMzE,KAAK8J,OAAQ9J,KAAK6J,OAAQ3E,EAAOnF,YAAamF,EAAOpF,cACvEsC,cAAAC,IAcD,WACE,OAAOrC,KAAK6J,OAAOlE,WACpBvD,aAAAC,IAED,WACE,OAAOrC,KAAKyJ,aAAa,GAAGhG,YAC7BrB,aAAAC,IAED,WACE,OAAOrC,KAAKyJ,aAAa,GAAGhG,YAC7BrB,eAAAC,IAED,WACE,OAAOrC,KAAKyJ,aAAa,MAC1BrH,eAAAC,IAED,WACE,OAAOrC,KAAKyJ,aAAa,UChHhB2C,cA8BV,OAAAjK,GAxBD,SAAmBkK,EAAeC,EAAeC,GA0BzCvM,eAA2C,KAzBvCqM,EAAMvH,OAAS,GAAzBtD,MACA,IAAMmE,EAAkB0G,EAAM,GAAG1G,QAE/B0G,EAAMG,OAAM,SAAAC,GAAI,OAAIA,EAAK9G,UAAYA,MADvCnE,MAKA,IAAMkL,EAAeJ,EAAM9H,QACjB6H,EAAM,GAAG1C,cAAc+C,IAAjClL,WAC4B,IAAX+K,GAA0BF,EAAMA,EAAMvH,OAAS,GAAG6E,cAAc4C,EAAO/H,UAAxFhD,MAGA,IADA,IACuCmL,EADjCC,EAAgB,CAACF,GACvBG,EAAAC,EAAwBT,EAAMU,aAASJ,EAAAE,KAAAG,MAAE,CAAA,IAAAC,EAAAN,EAAA9E,MAA1B4E,EAAIQ,KACXC,EAAeN,EADVK,MAEDC,EAAajJ,OAAOwI,EAAK5C,SAAWqD,EAAajJ,OAAOwI,EAAK3C,SAAvEtI,MACA,IAAM+K,EAASW,EAAajJ,OAAOwI,EAAK5C,QAAU4C,EAAK3C,OAAS2C,EAAK5C,OACrE+C,EAAKO,KAAKZ,GAGZvM,KAAKqM,MAAQA,EACbrM,KAAK4M,KAAOA,EACZ5M,KAAKsM,MAAQA,EACbtM,KAAKuM,OAASA,MACfnK,eAAAC,IAID,WACE,GAAuB,OAAnBrC,KAAKoN,UAAoB,OAAOpN,KAAKoN,UAEzC,IADA,IAC4CC,EADtCC,EAAsC,GAC5CC,EAAAT,EAAwB9M,KAAKqM,MAAMU,aAASM,EAAAE,KAAAP,MAAE,CAAA,IAAAQ,EAAAH,EAAAxF,MAA/B4E,EAAIe,KACjBF,EAAOH,KACLnN,KAAK4M,KAFIY,MAEIvJ,OAAOwI,EAAK5C,QACrB,IAAIpF,GAAMgI,EAAKtC,SAAS1G,SAAUgJ,EAAKrC,SAAS3G,SAAUgJ,EAAKtC,SAASxI,SAAU8K,EAAKrC,SAASzI,UAChG,IAAI8C,GAAMgI,EAAKrC,SAAS3G,SAAUgJ,EAAKtC,SAAS1G,SAAUgJ,EAAKrC,SAASzI,SAAU8K,EAAKtC,SAASxI,WAGxG,IAAM8L,EAAUH,EAAOI,MAAM,GAAGC,QAAO,SAACC,EAAaC,GAAY,OAAKD,EAAYjN,SAASkN,KAAeP,EAAO,IACjH,OAAQtN,KAAKoN,UAAY,IAAI3I,GAAMzE,KAAKsM,MAAOtM,KAAKuM,OAAQkB,EAAQ1N,YAAa0N,EAAQ3N,cAC1FsC,cAAAC,IAED,WACE,OAAOrC,KAAKqM,MAAM,GAAG1G,eC7CzB,SAAgBmI,GACdC,EACAzD,EACAQ,GAEA,IAAMkD,EAAqBD,EAASxI,MAAM+E,GAEpC2D,EAAcD,EAAmBpN,SAASkK,GAAc9J,OAAOgN,GACrE,OAAO,IAAItL,EAAQuL,EAAYnO,UAAWmO,EAAYlO,aCfxD,SAAgBmO,GAAgBC,EAAY5N,EAAQ6N,EAAiBC,GAMnE,GALUD,EAAU,GAApB5M,MAEU2M,EAAMrJ,QAAUsJ,GAA1B5M,MAGqB,IAAjB2M,EAAMrJ,OAER,OADAqJ,EAAMhB,KAAK5M,GACJ,KAEP,IAAM+N,EAASH,EAAMrJ,SAAWsJ,EAEhC,GAAIE,GAAUD,EAAWF,EAAMA,EAAMrJ,OAAS,GAAIvE,IAAQ,EACxD,OAAOA,EAMT,IAHA,IAAIgO,EAAK,EACPC,EAAKL,EAAMrJ,OAENyJ,EAAKC,GAAI,CACd,IAAMC,EAAOF,EAAKC,IAAQ,EACtBH,EAAWF,EAAMM,GAAMlO,IAAQ,EACjCgO,EAAKE,EAAM,EAEXD,EAAKC,EAIT,OADAN,EAAMO,OAAOH,EAAI,EAAGhO,GACb+N,EAASH,EAAMQ,MAAS,cCVnBC,GACdC,EACAC,GAKA,OAFUD,EAAEvE,YAAY7G,SAASQ,OAAO6K,EAAExE,YAAY7G,WAAtDjC,MACUqN,EAAE/D,aAAarH,SAASQ,OAAO6K,EAAEhE,aAAarH,WAAxDjC,MACIqN,EAAE/D,aAAahK,QAAQgO,EAAEhE,cACvB+D,EAAEvE,YAAYxJ,QAAQgO,EAAExE,aACnB,EAGLuE,EAAEvE,YAAYzJ,SAASiO,EAAExE,cACnB,EAED,EAILuE,EAAE/D,aAAajK,SAASiO,EAAEhE,cACrB,GAEC,WAMEiE,GACdF,EACAC,GAEA,IAAME,EAASJ,GAAsBC,EAAGC,GACxC,OAAe,IAAXE,EACKA,EAILH,EAAEZ,YAAYpN,SAASiO,EAAEb,cACnB,EACCY,EAAEZ,YAAYlN,YAAY+N,EAAEb,aAC9B,EAIFY,EAAEI,MAAMrC,KAAK9H,OAASgK,EAAEG,MAAMrC,KAAK9H,OAc5C,IAAaoK,cAkDX,SAAAA,EACED,EACAE,EACAC,GAEApP,KAAKiP,MAAQA,EACbjP,KAAKoP,UAAYA,EAEjB,IAAM3F,EAAwC,IAAIzE,MAAMiK,EAAMrC,KAAK9H,QACnE,GAAIsK,IAAc/R,kBAAUgS,YAAa,CAC7BF,EAAO1L,SAASQ,OAAOgL,EAAM3C,QAAvC9K,MACAiI,EAAa,GAAK0F,EAAO3K,QACzB,IAAK,IAAI8K,EAAI,EAAGA,EAAIL,EAAMrC,KAAK9H,OAAS,EAAGwK,IAAK,CAC9C,IACAC,EADaN,EAAM5C,MAAMiD,GACGjF,gBAAgBZ,EAAa6F,IACzD7F,EAAa6F,EAAI,GADEC,KAGrBvP,KAAKsK,YAAc9G,GAAeQ,qBAAqBiL,EAAM3C,MAAO6C,EAAOrP,UAAWqP,EAAOpP,aAC7FC,KAAK8K,aAAetH,GAAeQ,qBACjCiL,EAAM1C,OACN9C,EAAaA,EAAa3E,OAAS,GAAGhF,UACtC2J,EAAaA,EAAa3E,OAAS,GAAG/E,iBAEnC,CACKoP,EAAO1L,SAASQ,OAAOgL,EAAM1C,SAAvC/K,MACAiI,EAAaA,EAAa3E,OAAS,GAAKqK,EAAO3K,QAC/C,IAAK,IAAI8K,EAAIL,EAAMrC,KAAK9H,OAAS,EAAGwK,EAAI,EAAGA,IAAK,CAC9C,IACAE,EADaP,EAAM5C,MAAMiD,EAAI,GACFpE,eAAezB,EAAa6F,IACvD7F,EAAa6F,EAAI,GADCE,KAGpBxP,KAAKsK,YAAc9G,GAAeQ,qBAChCiL,EAAM3C,MACN7C,EAAa,GAAG3J,UAChB2J,EAAa,GAAG1J,aAElBC,KAAK8K,aAAetH,GAAeQ,qBAAqBiL,EAAM1C,OAAQ4C,EAAOrP,UAAWqP,EAAOpP,aAEjGC,KAAKyP,eAAiB,IAAIhL,GACxBzE,KAAKsK,YAAY7G,SACjBzD,KAAK8K,aAAarH,SAClBzD,KAAKsK,YAAY3I,SACjB3B,KAAK8K,aAAanJ,UAEpB3B,KAAKiO,YAAcH,GAAmBmB,EAAMlB,SAAU/N,KAAKsK,YAAatK,KAAK8K,cApE/EoE,EAKcQ,QAAP,SACLT,EACAU,GAEA,OAAO,IAAIT,EAAMD,EAAOU,EAAUtS,kBAAUgS,cAG9CH,EAKcU,SAAP,SACLX,EACAY,GAEA,OAAO,IAAIX,EAAMD,EAAOY,EAAWxS,kBAAUyS,eAkD/C,IAAA1P,EAAA8O,EAAA7O,UA4MC,OA5MDD,EAIO2P,iBAAA,SAAiBC,GAEtB,GADWA,EAAkBnP,SAASlC,IAAtC6C,MACIxB,KAAKoP,YAAc/R,kBAAUyS,aAC/B,OAAO9P,KAAK8K,aAEZ,IAAMmF,EAA4B,IAAIpQ,EAASjB,GAC5C2B,IAAIyP,GACJ1P,SACAK,SAASX,KAAK8K,aAAanJ,UAAUA,SACxC,OAAO6B,GAAeM,cAAc9D,KAAK8K,aAAarH,SAAUwM,IAIpE7P,EAIO8P,gBAAA,SAAgBF,GAErB,GADWA,EAAkBnP,SAASlC,IAAtC6C,MACIxB,KAAKoP,YAAc/R,kBAAUgS,YAC/B,OAAOrP,KAAKsK,YAEZ,IAAM6F,EAA2B,IAAItQ,EAASjB,GAAK2B,IAAIyP,GAAmBrP,SAASX,KAAKsK,YAAY3I,UACjGA,SACH,OAAO6B,GAAeM,cAAc9D,KAAKsK,YAAY7G,SAAU0M,IAInEjB,EAcckB,iBAAP,SACL/D,EACAgE,EACAC,EAAoBC,EAGpBC,EACAC,EACAC,oBAJuD,GAAEH,EAAAI,EAAAtL,EAAvDuL,cAAAA,WAAaD,EAAG,EAACA,EAAAE,EAAAxL,EAAEyL,QAAAA,WAAOD,EAAG,EAACA,WAEhCL,IAAAA,EAAuB,aACvBC,IAAAA,EAAyCJ,YACzCK,IAAAA,EAA8D,IAEpDrE,EAAMvH,OAAS,GAAzBtD,MACUsP,EAAU,GAApBtP,MACU6O,IAAqBI,GAAgBD,EAAa1L,OAAS,GAArEtD,MAIA,IAFA,IAAMmO,EAAWc,EAAajM,QACxBuM,EAAWT,EAAY9L,QACpB8K,EAAI,EAAGA,EAAIjD,EAAMvH,OAAQwK,IAAK,CACrC,IAAM7C,EAAOJ,EAAMiD,GAEnB,IAAK7C,EAAK5C,OAAO5F,OAAO0L,EAASlM,WAAcgJ,EAAK3C,OAAO7F,OAAO0L,EAASlM,aACvEgJ,EAAKtC,SAASrJ,QAAQnC,KAAS8N,EAAKrC,SAAStJ,QAAQnC,GAAzD,CAEA,IAAIkR,SACJ,IACIA,EAAapD,EAAKpC,gBAAgBsF,MACpC,MAAOvJ,GAEP,GAAIA,EAAM4K,+BACR,SAEF,MAAM5K,EAGR,GAAIyJ,EAAUpM,SAASQ,OAAO8M,GAC5B7C,GACEwC,EACA,IAAIxB,EACF,IAAI9C,MAAK6E,OAAKT,GAAc/D,IAAO4D,EAAiB5M,SAAU6M,GAC9DD,EACAhT,kBAAUgS,aAEZuB,EACA7B,SAEG,GAAI+B,EAAU,GAAKzE,EAAMvH,OAAS,EAAG,CAC1C,IAAMoM,EAAyB7E,EAAMqB,MAAM,EAAG4B,GAAG2B,OAAO5E,EAAMqB,MAAM4B,EAAI,EAAGjD,EAAMvH,SAGjFoK,EAAMkB,iBACJc,EACAb,EACAC,EACA,CACEM,cAAAA,EACAE,QAASA,EAAU,MACpBG,OACGT,GAAc/D,IAClBoD,EACAa,KAKN,OAAOA,GAGTtQ,EAIO+Q,oBAAA,SAAoBnB,GACzB,OAAO,IAAIvL,GACTzE,KAAKsK,YAAY7G,SACjBzD,KAAK8K,aAAarH,SAClBzD,KAAKkQ,gBAAgBF,GAAmBrO,SACxC3B,KAAK+P,iBAAiBC,GAAmBrO,WAI7CuN,EAeckC,kBAAP,SACL/E,EACAgF,EACAC,EAA0CC,EAG1Cf,EACAgB,EACAd,oBAJuD,GAAEa,EAAAE,EAAAvI,EAAvD0H,cAAAA,WAAaa,EAAG,EAACA,EAAAC,EAAAxI,EAAE4H,QAAAA,WAAOY,EAAG,EAACA,WAEhClB,IAAAA,EAAuB,aACvBgB,IAAAA,EAA0CF,YAC1CZ,IAAAA,EAA+D,IAErDrE,EAAMvH,OAAS,GAAzBtD,MACUsP,EAAU,GAApBtP,MACU8P,IAAsBE,GAAiBhB,EAAa1L,OAAS,GAAvEtD,MAIA,IAFA,IAAMqO,EAAY2B,EAAchN,QAC1BmN,EAAUN,EAAW7M,QAClB8K,EAAI,EAAGA,EAAIjD,EAAMvH,OAAQwK,IAAK,CACrC,IAAM7C,EAAOJ,EAAMiD,GAEnB,IAAK7C,EAAK5C,OAAO5F,OAAO4L,EAAUpM,WAAcgJ,EAAK3C,OAAO7F,OAAO4L,EAAUpM,aACzEgJ,EAAKtC,SAASrJ,QAAQnC,KAAS8N,EAAKrC,SAAStJ,QAAQnC,GAAzD,CAEA,IAAIgR,SACJ,IACIA,EAAYlD,EAAKvB,eAAe2E,MAClC,MAAOzJ,GAEP,GAAIA,EAAMwL,4BACR,SAEF,MAAMxL,EAGR,GAAIuJ,EAASlM,SAASQ,OAAO0N,GAC3BzD,GACEwC,EACA,IAAIxB,EACF,IAAI9C,IAAOK,GAAIwE,OAAKT,GAAea,EAAYC,EAAkB7N,UACjE6N,EACAjU,kBAAUyS,cAEZc,EACA7B,SAEG,GAAI+B,EAAU,GAAKzE,EAAMvH,OAAS,EAAG,CAC1C,IAAMoM,EAAyB7E,EAAMqB,MAAM,EAAG4B,GAAG2B,OAAO5E,EAAMqB,MAAM4B,EAAI,EAAGjD,EAAMvH,SAGjFoK,EAAMkC,kBACJF,EACAG,EACAC,EACA,CACEV,cAAAA,EACAE,QAASA,EAAU,IAEpBrE,GAAIwE,OAAKT,GACVb,EACAe,KAKN,OAAOA,GACRxB,cCxXa2C,GAAW7I,EAAgBC,GAC/BD,IAAWC,GAArBzH,MACA,IAAA6D,EAAyB2D,EAAOjC,cAAgBkC,EAAOlC,cAAgB,CAACiC,EAAQC,GAAU,CAACA,EAAQD,GAA5Fa,EAAMxE,KAAEyE,EAAMzE,KAErB,MADmC,+CAAzBwE,EAAO9C,eAAjBvF,MACO,CAACqI,EAAQC,GAiClB,SAAgBgI,GAAanC,EAAgBoC,EAAiBC,GAClD1T,EAAKyC,YAAY4O,EAAUrR,EAAKC,OAAO,KAAjDiD,MAEElD,EAAKyC,YAAYgR,EAAWzT,EAAKC,OAAO,KAAOD,EAAKyC,YAAYiR,EAAY1T,EAAKC,OAAO,KAD1FiD,MAKA,IAAMyQ,EAAkB3T,EAAKqC,SAASgP,EAAUrR,EAAKC,OAAO,MACtDuB,EAAYxB,EAAKqC,SAASsR,EAAiBD,GAC3CjS,EAAczB,EAAKiC,IAAIjC,EAAKqC,SAASoR,EAAWzT,EAAKC,OAAO,MAAQ0T,GAC1E,OAAO3T,EAAK0C,OAAOlB,EAAWC,GAMhC,SAAgBmS,GAAYrC,EAAiBkC,EAAiBC,GAClD1T,EAAKyC,YAAY8O,EAAWvR,EAAKC,OAAO,KAAlDiD,MAEElD,EAAKyC,YAAYgR,EAAWzT,EAAKC,OAAO,KAAOD,EAAKyC,YAAYiR,EAAY1T,EAAKC,OAAO,KAD1FiD,MAKA,IAAM1B,EAAYxB,EAAKqC,SAASrC,EAAKqC,SAASoR,EAAWlC,GAAYvR,EAAKC,OAAO,MAC3EwB,EAAczB,EAAKqC,SAASrC,EAAKsC,SAASoR,EAAYnC,GAAYvR,EAAKC,OAAO,MACpF,OAAOD,EAAKiC,IAAIjC,EAAK0C,OAAOlB,EAAWC,GAAczB,EAAKC,OAAO,ICvDnE,SAAgB4T,GACdC,EACAC,EACAC,EACAC,GAGEjU,EAAKyC,YAAYqR,EAAiB9T,EAAKC,OAAO,KAAOD,EAAKyC,YAAYsR,EAAiB/T,EAAKC,OAAO,KADrGiD,MAKElD,EAAKyC,YAAYuR,EAAUhU,EAAKC,OAAO,KAAOD,EAAKyC,YAAYwR,EAAUjU,EAAKC,OAAO,KADvFiD,MAUA,IAAMgR,EAAelU,EAAK0C,OAAO1C,EAAKqC,SAAS4R,EAAUH,GAAkBE,GACrEG,EAAOnU,EAAKyC,YAAYyR,EAAcH,GAE5C,GAAI/T,EAAKoC,MAAM8R,EAAcH,GAC3B,MAAO,EAAC,EAAO/T,EAAKC,OAAO,IAG7B,IAAMmU,EAAiBpU,EAAKqC,SAAS2R,EAAUC,GAE/C,IACE,IAAMI,EAAW/K,GACftJ,EAAK0C,OACH1C,EAAKqC,SAASrC,EAAKqC,SAAS+R,EAAgBpU,EAAKC,OAAO,MAAQkU,EAAOL,EAAkBC,GACzF/T,EAAKqC,SAAS8R,EAAOJ,EAAkBD,EAAiB9T,EAAKC,OAAO,QAIlEqU,EAAYtU,EAAK0C,OAAO1C,EAAKqC,SAAS8R,EAAOH,EAAWC,EAAUjU,EAAKC,OAAO,MAAQD,EAAKC,OAAO,MAExG,OAAID,EAAKuC,SAAS8R,EAAUC,GACnB,EAAC,EAAOtU,EAAKC,OAAO,IAItB,CAACkU,EADSnU,EAAKsC,SAAS+R,EAAUC,IAEzC,MAAOxM,GACP,MAAO,EAAC,EAAO9H,EAAKC,OAAO,KAY/B,SAAgBsU,GACdP,EACAC,EACAH,EACAC,GAGE/T,EAAKyC,YAAYuR,EAAUhU,EAAKC,OAAO,KAAOD,EAAKyC,YAAYwR,EAAUjU,EAAKC,OAAO,KADvFiD,MAKA,IAAAsR,EAAyBX,GAA6BC,EAAiBC,EAAiBC,EAAUC,GAA3FE,EAAIK,KAAEnD,EAAQmD,KAErB,GAAIxU,EAAKoC,MAAMiP,EAAUrR,EAAKC,OAAO,IACnC,MAAO,CAAC+T,EAAUC,GAGpB,GAAIE,EAAM,CACR,IAAM5C,EAAYiC,GAAanC,EAAU2C,EAAUC,GACnD,MAAO,CAACjU,EAAKiC,IAAI+R,EAAU3C,GAAWrR,EAAKsC,SAAS2R,EAAU1C,IAE9D,IAAMA,EAAYiC,GAAanC,EAAU4C,EAAUD,GACnD,MAAO,CAAChU,EAAKsC,SAAS0R,EAAUzC,GAAYvR,EAAKiC,IAAIgS,EAAU5C,aAcnDoD,GACdC,EACAC,EACA5H,EACA6H,EACAvH,EACAC,GAEA,IAAIuH,EAAsB9H,EAE1B,GAAIM,GAASrN,EAAKyC,YAAY6K,EAAOtN,EAAKC,OAAO,IAAK,CACpD,IAAMwN,EAAQnE,GAAKtJ,EAAKqC,SAASqS,EAAWC,IACtCjH,EAAYpE,GAAKgE,GAEvB,GAAItN,EAAKyC,YAAYgL,EAAOC,GAAY,CACtC,IAAMoH,EAAa/H,EACbgI,EAAa/U,EAAKsC,SAASmL,EAAOC,GAClCjM,EAAczB,EAAKiC,IAAIjC,EAAKqC,SAASoL,EAAOzN,EAAKC,OAAO,IAAKyN,GAC7DC,EAAe3N,EAAK0C,OAAO1C,EAAKqC,SAASyS,EAAYC,GAAatT,GACxEoT,EAAsB7U,EAAKiC,IAAI8K,EAAaY,IAIhD,MAAO,CACL3N,EAAK0C,OAAO1C,EAAKqC,SAASqS,EAAWE,GAAkBC,GACvD7U,EAAK0C,OAAO1C,EAAKqC,SAASsS,EAAWC,GAAkBC,IC1E3D,IAAaG,cAAb,SAAAA,IACUtT,eAAsC,IAAIuT,IAC1CvT,kBAA+C,IAAIuT,IACnDvT,cASJ,IAAIuT,IAER,IAAAnT,EAAAkT,EAAAjT,UA4GiB,OA5GjBD,EAGAoT,oBAAA,SAAoBC,EAAcC,EAAcC,GAC9CF,EAAOnN,GAAkBmN,GACzBC,EAAOpN,GAAkBoN,GAEpB1T,KAAK4T,UAAUC,IAAIJ,IACtBzT,KAAK4T,UAAUnS,IAAIgS,EAAM,IAAIK,KAE/B9T,KAAK4T,UAAUvR,IAAIoR,GAAOlT,IAAImT,GAEzB1T,KAAK+T,aAAaF,IAAIJ,IACzBzT,KAAK+T,aAAatS,IAAIgS,EAAM,IAAIF,KAElCvT,KAAK+T,aAAa1R,IAAIoR,GAAOhS,IAAIiS,EAAMC,IAGzCvT,EAGA4T,gBAAA,SAAgBN,EAAc1K,EAAgBC,EAAgBqJ,EAAgBC,EAAgBlH,GAC5FrL,KAAKiU,SAASxS,IAAI6E,GAAkBoN,GAAO,CACzC1K,OAAQ1C,GAAkB0C,GAC1BC,OAAQ3C,GAAkB2C,GAC1BqJ,SAAAA,EACAC,SAAAA,EACAlH,YAAAA,KAEHjL,EAEK8T,8BAAkB,IAAAC,EAAAC,EAAAC,IAAAC,GAAxB,SAAAC,EAAyBd,GAAY,IAAAe,EAAA,OAAAH,IAAAI,YAAAC,GAAA,cAAAA,EAAAC,GAAA,OAEG,OADtClB,EAAOnN,GAAkBmN,GACnBe,EAAQxU,KAAK4T,UAAUvR,IAAIoR,GAAKiB,EAAA7F,IAC/BvQ,EAAKC,OAAOiW,EAAQA,EAAMI,KAAO,OAAEL,YAHpB,OAIvB,SAJuBM,GAAA,OAAAV,EAAAW,WAAAjQ,eAAAzE,EAMlB2U,0BAAc,IAAAC,EAAAZ,EAAAC,IAAAC,GAApB,SAAAW,EAAqBxB,EAAcyB,EAAcC,GAAW,IAAAX,EAAAY,EAAAC,EAAAC,EAAAC,EAAA,OAAAlB,IAAAI,YAAAe,GAAA,cAAAA,EAAAb,GAAA,OAEpB,GADtClB,EAAOnN,GAAkBmN,GACnBe,EAAQxU,KAAK4T,UAAUvR,IAAIoR,IAEvB+B,EAAAb,IAAA,MAAA,OAAAa,EAAA3G,IACD,CAAE2F,MAAO,GAAIiB,SAAS,IAAO,OAQiB,OALjDL,EAAYpQ,MAAM8B,KAAK0N,GACvBa,EAAY/W,EAAK2J,SAASiN,GAC1BI,EAAWhX,EAAK2J,SAASkN,GAEzBI,EAASH,EAAU1H,MAAM2H,EAAWA,EAAYC,GACCE,EAAA3G,IAEhD,CACL2F,MAAOe,EACPE,QAJcJ,EAAYC,EAAWF,EAAUtQ,YAKhDmQ,YAlBiB,OAmBnB,SAnBmBS,EAAAC,EAAAC,GAAA,OAAAZ,EAAAF,WAAAjQ,eAAAzE,EAqBdyV,4BAAgB,IAAAC,EAAA1B,EAAAC,IAAAC,GAAtB,SAAAyB,EAAuBtC,EAAcC,GAAY,IAAAK,EAAA,OAAAM,IAAAI,YAAAuB,GAAA,cAAAA,EAAArB,GAAA,OAIC,GAHhDlB,EAAOnN,GAAkBmN,GACzBC,EAAOpN,GAAkBoN,GAEnBK,EAAe/T,KAAK+T,aAAa1R,IAAIoR,IAC1BuC,EAAArB,IAAA,MAAA,OAAAqB,EAAAnH,IACRvQ,EAAKC,OAAO,IAAE,OAAA,OAAAyX,EAAAnH,IAGhBkF,EAAa1R,IAAIqR,IAASpV,EAAKC,OAAO,OAAEwX,YAT3B,OAUrB,SAVqBE,EAAAC,GAAA,OAAAJ,EAAAhB,WAAAjQ,eAAAzE,EAYhB+V,8BAAkB,IAAAC,EAAAhC,EAAAC,IAAAC,GAAxB,SAAA+B,EAAyB5C,EAAcyB,EAAcC,GAAW,IAAAmB,EAAAC,EAAA1J,EAAAF,EAAA+G,EAAAC,EAAA6C,EAAAC,EAAA,OAAApC,IAAAI,YAAAiC,GAAA,cAAAA,EAAA/B,GAAA,OAChC,OAA9BlB,EAAOnN,GAAkBmN,GAAKiD,EAAA/B,IACJ3U,KAAK+U,eAAetB,EAAMyB,EAAQC,GAAM,OAE5DoB,EAA0B,GAAE1J,EAAAC,GAF5BwJ,EAAWI,EAAAC,GAIcnC,OAAK,OAAA,IAAA7H,EAAAE,KAAAG,MAAA0J,EAAA/B,IAAA,MAArB,OAAJjB,EAAI/G,EAAA9E,MAAA6O,EAAA/B,IACS3U,KAAK6V,iBAAiBpC,EAAMC,GAAK,OAA1C,OAAPC,EAAO+C,EAAAC,EAAAD,EAAA/B,IACU3U,KAAK4W,YAAYlD,GAAK,OAGvC+C,EAAkBnY,EAAKoC,OAHvB8V,EAAQE,EAAAC,GAG8BtL,YAAa/M,EAAKC,OAAO,IACjED,EAAKC,OAAO,GACZD,EAAK0C,OAAO1C,EAAKqC,SAASgT,EAASrV,EAAKC,OAAO,MAASiY,EAASnL,aAErEkL,EAAUpJ,KAAK,CACbuG,KAAAA,EACA1K,OAAQwN,EAASxN,OACjBC,OAAQuN,EAASvN,OACjB0K,QAAAA,EACArB,SAAUkE,EAASlE,SACnBC,SAAUiE,EAASjE,SACnBlH,YAAamL,EAASnL,YACtBoL,gBAAAA,IACA,OAAAC,EAAA/B,IAAA,MAAA,OAAA,OAAA+B,EAAA7H,IAGG,CACL0H,UAAAA,EACAd,QAASa,EAAYb,aACtBY,YA9BqB,OA+BvB,SA/BuBQ,EAAAC,EAAAC,GAAA,OAAAX,EAAAtB,WAAAjQ,eAAAzE,EAiClB4W,yBAAa,IAAAC,EAAA7C,EAAAC,IAAAC,GAAnB,SAAA4C,EAAoBzD,EAAcC,GAAY,OAAAW,IAAAI,YAAA0C,GAAA,cAAAA,EAAAxC,GAAA,OAAA,OAAAwC,EAAAxC,IACtB3U,KAAK6V,iBAAiBpC,EAAMC,GAAK,OAA1C,OAAAyD,EAAAtI,IACNvQ,EAAKyC,YADCoW,EAAAR,EACoBrY,EAAKC,OAAO,QAAG2Y,YAF/B,OAGlB,SAHkBE,EAAAC,GAAA,OAAAJ,EAAAnC,WAAAjQ,eAAAzE,EAKbwW,uBAAW,IAAAU,EAAAlD,EAAAC,IAAAC,GAAjB,SAAAiD,EACE7D,GAAY,IAAA8D,EAAA,OAAAnD,IAAAI,YAAAgD,GAAA,cAAAA,EAAA9C,GAAA,OASwB,GADpCjB,EAAOpN,GAAkBoN,GACnB8D,EAAOxX,KAAKiU,SAAS5R,IAAIqR,IAEtB+D,EAAA9C,IAAA,MAAA,MACD,IAAIxU,iCAAiCuT,GAAO,OAAA,OAAA+D,EAAA5I,IAG7C2I,MAAID,YAhBI,OAiBhB,SAjBgBG,GAAA,OAAAJ,EAAAxC,WAAAjQ,eAAAyO,KAuBNqE,cACX,SAAAA,EAAoBC,GAAA5X,kBAAA4X,EAEpB,IAAAC,EAAAF,EAAAtX,UAkEyB,OAlEzBwX,EAGM3D,mBAAkB,WAAA,IAAA4D,EAAA1D,EAAAC,IAAAC,GAAxB,SAAAyD,EAAyBtE,GAAY,OAAAY,IAAAI,YAAAuD,GAAA,cAAAA,EAAArD,GAAA,OAAA,OAAAqD,EAAAnJ,IAC5B7O,KAAK4X,aAAa1D,mBAAmBT,OAAKsE,YAD3B,OAEvB,SAFuBE,GAAA,OAAAH,EAAAhD,WAAAjQ,YAAA,GAIxBgT,EAGM9C,eAAc,WAAA,IAAAmD,EAAA9D,EAAAC,IAAAC,GAApB,SAAA6D,EAAqB1E,EAAcyB,EAAcC,GAAW,OAAAd,IAAAI,YAAA2D,GAAA,cAAAA,EAAAzD,GAAA,OAES,OADzDrW,EAAKwJ,mBAAmBoN,EAAQ5W,EAAKC,OAAO,KAAtDiD,MACUlD,EAAKyC,YAAYoU,EAAO7W,EAAKC,OAAO,KAA9CiD,MAAmE4W,EAAAvJ,IAE5D7O,KAAK4X,aAAa7C,eAAetB,EAAMyB,EAAQC,OAAMgD,YAJ1C,OAKnB,SALmBE,EAAAC,EAAAC,GAAA,OAAAL,EAAApD,WAAAjQ,YAAA,GAOpBgT,EAGMhC,iBAAgB,WAAA,IAAA2C,EAAApE,EAAAC,IAAAC,GAAtB,SAAAmE,EAAuBhF,EAAcC,GAAY,OAAAW,IAAAI,YAAAiE,GAAA,cAAAA,EAAA/D,GAAA,OAAA,OAAA+D,EAAA7J,IACxC7O,KAAK4X,aAAa/B,iBAAiBpC,EAAMC,OAAK+E,YADjC,OAErB,SAFqBE,EAAAC,GAAA,OAAAJ,EAAA1D,WAAAjQ,YAAA,GAItBgT,EAGM1B,mBAAkB,WAAA,IAAA0C,EAAAzE,EAAAC,IAAAC,GAAxB,SAAAwE,EAAyBrF,EAAcyB,EAAcC,GAAW,OAAAd,IAAAI,YAAAsE,GAAA,cAAAA,EAAApE,GAAA,OAEK,OADzDrW,EAAKwJ,mBAAmBoN,EAAQ5W,EAAKC,OAAO,KAAtDiD,MACUlD,EAAKyC,YAAYoU,EAAO7W,EAAKC,OAAO,KAA9CiD,MAAmEuX,EAAAlK,IAE5D7O,KAAK4X,aAAazB,mBAAmB1C,EAAMyB,EAAQC,OAAM2D,YAJ1C,OAKvB,SALuBE,EAAAC,EAAAC,GAAA,OAAAL,EAAA/D,WAAAjQ,YAAA,GAOxBgT,EAGMb,cAAa,WAAA,IAAAmC,EAAA/E,EAAAC,IAAAC,GAAnB,SAAA8E,EAAoB3F,EAAcC,GAAY,OAAAW,IAAAI,YAAA4E,GAAA,cAAAA,EAAA1E,GAAA,OAAA,OAAA0E,EAAAxK,IACrC7O,KAAK4X,aAAaZ,cAAcvD,EAAMC,OAAK0F,YADjC,OAElB,SAFkBE,EAAAC,GAAA,OAAAJ,EAAArE,WAAAjQ,YAAA,GAInBgT,EAGM2B,sBAAqB,WAAA,IAAAC,EAAArF,EAAAC,IAAAC,GAA3B,SAAAoF,EAA4BjG,GAAY,IAAA8C,EAAArB,EAAAC,EAAAjQ,EAAA,OAAAmP,IAAAI,YAAAkF,GAAA,cAAAA,EAAAhF,GAAA,OAChC4B,EAA0B,GAC5BrB,EAAS5W,EAAKC,OAAO,GACnB4W,EAAQ7W,EAAKC,OAAO,IAAI,OAEnB,OAAAob,EAAAhF,IACY3U,KAAKmW,mBAAmB1C,EAAMyB,EAAQC,GAAM,OAC9B,GAAnCoB,EAAUpJ,KAAI2H,MAAdyB,GADMrR,EAAMyU,EAAAhD,GACaJ,WAEpBrR,EAAOuQ,SAAOkE,EAAAhF,IAAA,MAAA,OAAAgF,EAAA9K,OAAA,OAInBqG,EAAS5W,EAAKiC,IAAI2U,EAAQC,GAAMwE,EAAAhF,IAAA,MAAA,OAAA,OAAAgF,EAAA9K,IAG3B0H,MAASmD,YAhBS,OAiB1B,SAjB0BE,GAAA,OAAAH,EAAA3E,WAAAjQ,YAAA,GAmB3BgT,EAGMgC,oBAAmB,WAAA,IAAAC,EAAA1F,EAAAC,IAAAC,GAAzB,SAAAyF,EACEtG,GAAY,IAAA8C,EAAA/B,EAAA,OAAAH,IAAAI,YAAAuF,GAAA,cAAAA,EAAArF,GAAA,OAAA,OAAAqF,EAAArF,IAKY3U,KAAKwZ,sBAAsB/F,GAAK,OACP,OAD3C8C,EAASyD,EAAArD,EACTnC,EAAQ,IAAIV,IAAIyC,EAAU0D,KAAI,SAAAC,GAAC,OAAIA,EAAExG,SAAMsG,EAAAnL,IAE1C,CACLsL,eAAgB5D,EAAUzR,OAC1BsV,WAAY5F,EAAMI,UACnBmF,YAZsB,OAaxB,SAbwBM,GAAA,OAAAP,EAAAhF,WAAAjQ,YAAA,GAAA8S,KCpN3B,SAAS2C,GAAM9U,GACb,WAAYA,EAAe7D,SAASC,SAAS,IAG/C,IAKsB2Y,cAIpB,SAAAA,KA4EC,OA3EDA,EAKcC,mBAAP,SACLC,EACAC,GAEA,IAAMC,EAAUF,EAAMnQ,YAAY7G,SAAS+D,SACrCoT,EAAWH,EAAM3P,aAAarH,SAAS+D,SAEjCmT,GAAWC,GAAvBpZ,QACY,QAASkZ,IAAYA,EAAQG,IAAM,GAA/CrZ,MAEA,IAWIsZ,EACA/V,EACA8C,EAbEkT,EAAa9U,GAAwByU,EAAQM,WAC7CrL,EAAmB2K,GAAMG,EAAMvK,gBAAgBwK,EAAQO,kBACvDpL,EAAoByK,GAAMG,EAAM1K,iBAAiB2K,EAAQO,kBACzDrO,EAAiB6N,EAAMxL,MAAMrC,KAAKqN,KAAI,SAACrQ,GAAY,OAAKA,EAAM1D,WAC9DgV,EACJ,QAASR,QACC3S,KAAKC,OAAM,IAAImT,MAAOC,UAAY,KAAQV,EAAQG,KAAKjZ,SAAS,SACjE8Y,EAAQQ,SAAStZ,SAAS,IAE/ByZ,EAAmBC,QAAQZ,EAAQa,eAKzC,OAAQd,EAAMrL,WACZ,KAAK/R,kBAAUgS,YACTsL,GACFG,EAAaO,EAAmB,qDAAuD,wBAEvFtW,EAAO,CAAC8K,EAAWjD,EAAMmO,EAAIG,GAC7BrT,EAAQ8H,GACCiL,GACTE,EAAaO,EAAmB,qDAAuD,wBAEvFtW,EAAO,CAAC4K,EAAUE,EAAWjD,EAAMmO,EAAIG,GACvCrT,EAlDO,QAoDPiT,EAAaO,EACT,wDACA,2BAEJtW,EAAO,CAAC4K,EAAUE,EAAWjD,EAAMmO,EAAIG,GACvCrT,EAzDO,OA2DT,MACF,KAAKxK,kBAAUyS,aACFuL,GAAX7Z,MACImZ,GACFG,EAAa,wBAEb/V,EAAO,CAAC8K,EAAWjD,EAAMmO,EAAIG,GAC7BrT,EAAQ8H,GACCiL,GACTE,EAAa,wBAEb/V,EAAO,CAAC8K,EAAWF,EAAU/C,EAAMmO,EAAIG,GACvCrT,EAvEO,QAyEPiT,EAAa,2BAEb/V,EAAO,CAAC8K,EAAWF,EAAU/C,EAAMmO,EAAIG,GACvCrT,EA5EO,OAgFb,MAAO,CACLiT,WAAAA,EACA/V,KAAAA,EACA8C,MAAAA,IAEH0S,i5BH9D0B1K,EAAiB2L,GAClCA,EAAS1W,QAAU,GAA7BtD,MACA,IAAMia,EAAkB,IAAIzW,MAAMwW,EAAS1W,OAAS,GACpD2W,EAAQA,EAAQ3W,OAAS,GAAK+K,EAC9B,IAAK,IAAIP,EAAIkM,EAAS1W,OAAS,EAAGwK,GAAK,EAAGA,IACxCmM,EAAQnM,GAAK4C,GAAYuJ,EAAQnM,EAAI,GAAIkM,EAASlM,GAAG,GAAIkM,EAASlM,GAAG,IAEvE,OAAOmM,kCApBqB9L,EAAgB6L,GAClCA,EAAS1W,QAAU,GAA7BtD,MACA,IAAMia,EAAkB,IAAIzW,MAAMwW,EAAS1W,OAAS,GACpD2W,EAAQ,GAAK9L,EACb,IAAK,IAAIL,EAAI,EAAGA,EAAIkM,EAAS1W,OAAQwK,IACnCmM,EAAQnM,EAAI,GAAKwC,GAAa2J,EAAQnM,GAAIkM,EAASlM,GAAG,GAAIkM,EAASlM,GAAG,IAExE,OAAOmM,sCnBhDyB9V,GAChC,OAAO3H,EAAkB2H,uCoBuHO+V,EAA4BxI,GAC5D,OAAOH,GACL2I,EAAapJ,SACboJ,EAAanJ,SACbmJ,EAAarQ,YACb6H,EACAwI,EAAa/P,MACb+P,EAAa9P,uDAYjB,SACE8P,EACAtJ,EACAC,EACAa,GAGE5U,EAAKwJ,mBAAmB4T,EAAarQ,YAAa6H,IAChD5U,EAAKyC,YAAYmS,EAAiB5U,EAAKC,OAAO,KAFlDiD,MAMA,IAAAma,EAA+B9I,GAC7B6I,EAAapJ,SACboJ,EAAanJ,SACbH,EACAC,GAGF,OAAOU,GAPS4I,KAAWA,KAUzBD,EAAarQ,YACb6H,EACAwI,EAAa/P,MACb+P,EAAa9P,+EpBhKgBjG,GAC/B,OAAOvH,EAAiBuH,qDmBrB1B,SAAwBiW,EAAiB5S,EAAgBC,EAAgB4S,GACvE,IAAAC,EAAyBjK,GAAW7I,EAAQC,GAO5C,MAFoB,MADH2S,EAJJE,KAAQA,KAIwBD,GACTnO,OAAO,IAAIqO,SAAS,GAAI,oBAQ9D,SAAsBC,EAAe1J,EAAgBC,GAMnD,OALUjU,EAAKyC,YAAYib,EAAS1d,EAAKC,OAAO,KAAhDiD,MAEElD,EAAKyC,YAAYuR,EAAUhU,EAAKC,OAAO,KAAOD,EAAKyC,YAAYwR,EAAUjU,EAAKC,OAAO,KADvFiD,MAIOlD,EAAK0C,OAAO1C,EAAKqC,SAASqb,EAASzJ,GAAWD,uCnBZrB3M,EAAiBO,GACjDlI,EAAkB2H,GAAWO,qCAGEP,EAAiBO,GAChD9H,EAAiBuH,GAAWO"}